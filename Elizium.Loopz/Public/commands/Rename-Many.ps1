
function Rename-Many {
  <#
  .NAME
    Rename-Many

  .SYNOPSIS
    Performs a bulk rename for all file system objects delivered through the pipeline,
  via regular expression replacement.

  .DESCRIPTION
    The user should assemble the candidate items from the file system, be they files or
  directories typically using Get-ChildItem, or can be any other function that delivers
  file systems items via the PowerShell pipeline. For each item in the pipeline,
  Rename-Many will perform a rename.
    Rename-Many is a powerful command and should be used with caution. Because of the
  potential of accidental misuse, a number of protections have been put in place:

  * By default, the command is locked. This means that the command will not actually
  perform any renames until it has been unlocked by the user. When locked, the command
  runs as though -WhatIf has been specified. There are indications in the output to show
  that the command is in a locked state (there is an indicator in the batch header and
  a 'Novice' indicator in the summary). To activate the command, the user needs to
  set the environment variable 'LOOPZ_REMY_LOCKED' to $false. The user should not
  unlock the command until they are comfortable with how to use this command properly
  and knows how to write regular expressions correctly. (See regex101.com)

  * An undo script is generated by default. If the user has invoked a rename operation
  by accident without specifying $WhatIf (or any other WhatIf equivalent like $Diagnose)
  then the user can execute the undo script to reverse the rename operation. The user
  should clearly do this immediately on recognising the error of their ways. In a panic,
  the user may terminate the command via ctrl-c. In this case, a partial undo script is
  still generated and should contain the undo operations for the renames that were
  performed up to the point of the termination request.
    The name of the undo script is based upon the current date and time and is displayed
  in the summary. (The user can, if they wish disable the undo feature if they don't want
  to have to manage the accumulation of undo scripts, by setting the environment variable
  LOOPZ_REMY_UNDO_DISABLED to $true)

  Another important point of note is that there are currently 3 modes of operation:
  'move', 'update' or 'cut':
  * 'move': requires an anchor, which may be an $Anchor pattern or
    either $Start or $End switches.
  * 'update': requires $With or $Paste without an anchor.
  * 'cut': no anchor or $With/$Paste specified, the $Pattern match is simply removed
    from the name.

  The following regular expression parameters:
  * $Pattern
  * $Anchor
  * $Copy
  can optionally have an occurrence value specified that can be used to select which
  match is active. In the case where a provided expression has multiple matches, the
  occurrence value can be used to single out which one. When no occurrence is specified,
  the default is the first match only. The occurrence for a parameter can be:

  * f: first occurrence
  * l: last occurrence
  * <number>: the nth occurrence
  The occurrence is specified after the regular expression eg:
  -Pattern '\w\d{2,3}', l
    which means match the Last occurrence of the expression.
  (Actually, an occurrence may be specified for $Include and $Except but there is no
  point in doing so because these patterns only provide a filtering function and play
  no part in the actual renaming process).

    A note about escaping. If a pattern needs to use an regular expression character as
  a literal, it must be escaped. There are multiple ways of doing this:
  * use the 'esc' function; eg: -Pattern $($esc('(\d{2})'))
  * use a leading ~; -Pattern '~(123)'

  The above 2 approaches escape the entire string. The second approach is more concise
  and avoids the necessary use of extra brackets and $.
  * use 'esc' alongside other string concatenation:
    eg: -Pattern $($esc('(123)') + '-(?<ccy>GBP|SEK)').
  This third method is required when the whole pattern should not be subjected to
  escaping.

  .PARAMETER Anchor
    Indicates that the rename operation will be a move of the token from its original point
  to the point indicated by Anchor. Anchor is a regular expression string applied to the
  pipeline item's name (after the $Pattern match has been removed). The $Pattern match that
  is removed is inserted at the position indicated by the anchor match in collaboration with
  the $Relation parameter.

  .PARAMETER AnchorEnd
    Similar to Anchor except that if the pattern specified by AnchorEnd does not match, then
  the Pattern match will be moved to the End. This is known as a Hybrid Anchor.

  .PARAMETER AnchorStart
    Similar to Anchor except that if the pattern specified by AnchorEnd does not match, then
  the Pattern match will be moved to the Start. This is known as a Hybrid Anchor.

  .PARAMETER Append
    Appends a literal string to end of items name

  .PARAMETER Condition
    Provides another way of filtering pipeline items. This is not typically specified on the
  command line, rather it is meant for those wanting to build functionality on top of Rename-Many.

  .PARAMETER Context
    Provides another way of customising Rename-Many. This is not typically specified on the
  command line, rather it is meant for those wanting to build functionality on top of Rename-Many.
  $Context should be a PSCustomObject with the following note properties:
  * Title (default: 'Rename') the name used in the batch header.
  * ItemMessage (default: 'Rename Item') the operation name used for each renamed item.
  * SummaryMessage (default: 'Rename Summary') the name used in the batch summary.
  * Locked (default: 'LOOPZ_REMY_LOCKED) the name of the environment variable which controls
    the locking of the command.
  * DisabledEnVar (default: 'LOOPZ_REMY_UNDO_DISABLED') the name of the environment variable
    which controls if the undo script feature is disabled.
  * UndoDisabledEnVar (default: 'LOOPZ_REMY_UNDO_DISABLED') the name of the environment
    variable which determines if the Undo feature is disabled. This allows any other function
    built on top of Rename-Many to control the undo feature for itself independently of
    Rename-Many.

  .PARAMETER Copy
    Regular expression string applied to the pipeline item's name (after the $Pattern match
  has been removed), indicating a portion which should be copied and re-inserted (via the
  $Paste parameter; see $Paste or $With). Since this is a regular expression to be used in
  $Paste/$With, there is no value in the user specifying a static pattern, because that
  static string can just be defined in $Paste/$With. The value in the $Copy parameter comes
  when a generic pattern is defined eg \d{3} (is non Literal), specifies any 3 digits as
  opposed to say '123', which could be used directly in the $Paste/$With parameter without
  the need for $Copy. The match defined by $Copy is stored in special variable ${_c} and
  can be referenced as such from $Paste and $With.

  .PARAMETER Cut
    Is a replacement for the Pattern parameter, when a Cut operation is required. The matched
  items will be removed from the item's name, and no other replacement occurs.

  .PARAMETER Diagnose
    switch parameter that indicates the command should be run in WhatIf mode. When enabled
  it presents additional information that assists the user in correcting the un-expected
  results caused by an incorrect/un-intended regular expression. The current diagnosis
  will show the contents of named capture groups that they may have specified. When an item
  is not renamed (usually because of an incorrect regular expression), the user can use the
  diagnostics along side the 'Not Renamed' reason to track down errors. When $Diagnose has
  been specified, $WhatIf does not need to be specified.

  .PARAMETER Directory
    switch to indicate only Directory items in the pipeline will be processed. If neither
  this switch or the File switch are specified, then both File and Directory items
  are processed.

  .PARAMETER Drop
    A string parameter (only applicable to move operations, ie Anchor/Star/End/hybrid) that
  defines what text is used to replace the Pattern match. So in this use-case, the user wants
  to move a particular token/pattern to another part of the name and at the same time drop a
  static string in the place where the $Pattern was removed from.

  .PARAMETER End
    Is another type of anchor used instead of $Anchor and specifies that the $Pattern match
  should be moved to the end of the new name.

  .PARAMETER Except
    Regular expression string applied to the original pipeline item's name (before the $Pattern
  match has been removed). Allows the user to exclude some items that have been fed in via the
  pipeline. Those items that match the exclusion are skipped during the rename batch.

  .PARAMETER File
    switch to indicate only File items in the pipeline will be processed. If neither
  this switch or the Directory switch are specified, then both File and Directory items
  are processed.

  .PARAMETER Include
    Regular expression string applied to the original pipeline item's name (before the $Pattern
  match has been removed). Allows the user to include some items that have been fed in via the
  pipeline. Only those items that match $Include pattern are included during the rename batch,
  the others are skipped. The value of the Include parameter comes when you want to define
  a pattern which pipeline items match, without it be removed from the original name, which is
  what happens with $Pattern. Eg, the user may want to specify the only items that should be
  considered a candidate to be renamed are those that match a particular pattern but doing so
  in $Pattern would simply remove that pattern. That may be ok, but if it's not, the user should
  specify a pattern in the $Include and use $Pattern for the match you do want to be moved
  (with Anchor/Start/End) or replaced (with $With/$Paste).

  .PARAMETER Paste
    Formatter parameter for Update operations. Can contain named/numbered group references
  defined inside regular expression parameters, or use special named references $0 for the whole
  Pattern match and ${_c} for the whole Copy match.

  .PARAMETER Pattern
    Regular expression string that indicates which part of the pipeline items' name that
  either needs to be moved or replaced as part of bulk rename operation. Those characters
  in the name which match are removed from the name.
    The pattern can be followed by an occurrence indicator. As the $Pattern parameter is
  strictly speaking an array, the user can specify the occurrence after the regular
  expression eg:
    $Pattern '(?<code>\w\d{2})', l

    => This indicates that the last match should be captured into named group 'code'.

  .PARAMETER Prepend
    Prefixes a literal string to start of items name

  .PARAMETER Relation
    Used in conjunction with the $Anchor parameter and can be set to either 'before' or
  'after' (the default). Defines the relationship of the $pattern match with the $Anchor
  match in the new name for the pipeline item.

  .PARAMETER Start
    Is another type of anchor used instead of $Anchor and specifies that the $Pattern match
  should be moved to the start of the new name.

  .PARAMETER Top
    A number indicating how many items to process. If it is known that the number of items
  that will be candidates to be renamed is large, the user can limit this to the first $Top
  number of items. This is typically used as an exploratory tool, to determine the effects
  of the rename operation.

  .PARAMETER Transform
    A script block which is given the chance to perform a modification to the finally named
  item. The transform is invoked prior to post-processing, so that the post-processing rules
  are not breached and the transform does not have to worry about breaking them. The transform
  function's signature is as follows:

  * Original: original item's name
  * Renamed: new name
  * CapturedPattern: pattern capture

  and should return the new name. If the transform does not change the name, it should return
  an empty string.

  .PARAMETER Whole
    Provides an alternative way to indicate that the regular expression parameters
  should be treated as a whole word (it just wraps the expression inside \b tokens).
  If set to '*', then it applies to all expression parameters otherwise a single letter
  can specify which of the parameters 'Whole' should be applied to. Valid values are:

  * 'p': $Pattern
  * 'a': $Anchor/AnchorEnd/AnchorStart
  * 'c': $Copy
  * 'i': $Include
  * 'x': $Except
  * '*': All the above
  (NB: Currently, can't be set to more than 1 of the above items at a time)

  .PARAMETER With
    This is a NON regular expression string. It would be more accurately described as a formatter,
  similar to the $Paste parameter. Defines what text is used as the replacement for the $Pattern
  match. Works in concert with $Relation (whereas $Paste does not). $With can reference special
  variables:

  * $0: the pattern match
  * ${_a}: the anchor match
  * ${_c}: the copy match
number of item processed
  When $Pattern contains named capture groups, these variables can also be referenced. Eg if the
  $Pattern is defined as '(?<day>\d{1,2})-(?<mon>\d{1,2})-(?<year>\d{4})', then the variables
  ${day}, ${mon} and ${year} also become available for use in $With or $Paste.
  Typically, $With is literal text which is used to replace the $Pattern match and is inserted
  according to the Anchor match, (or indeed $Start or $End) and $Relation. When using $With,
  whatever is defined in the $Anchor match is removed from the pipeline's name.

  .PARAMETER underscore
    The pipeline item which should either be an instance of FileInfo or DirectoryInfo.

  * MOVE EXAMPLES (anchored)

  .EXAMPLE 1
  Move a static string before anchor (consider file items only):

  gci ... | Rename-Many -File -Pattern 'data' -Anchor 'loopz' -Relation 'before'

  .EXAMPLE 2
  Move last occurrence of whole-word static string before anchor:

  gci ... | Rename-Many -Pattern 'data',l -Anchor 'loopz' -Relation 'before' -Whole p

  .EXAMPLE 3
  Move a static string before anchor and drop (consider Directory items only):

  gci ... | Rename-Many -Directory -Pattern 'data' -Anchor 'loopz' -Relation 'before' -Drop '-'

  .EXAMPLE 4
  Move a static string before anchor and drop (consider Directory items only), if anchor
  does not match, move the pattern match to end:
  
  gci ... | Rename-Many -Directory -Pattern 'data' -AnchorEnd 'loopz' -Relation 'before' -Drop '-'

  .EXAMPLE 5
  Move a static string to start and drop (consider Directory items only):

  gci ... | Rename-Many -Directory -Pattern 'data' -Start -Drop '-'

  .EXAMPLE 6
  Move a match before anchor:

  gci ... | Rename-Many -Pattern '\d{2}-data' -Anchor 'loopz' -Relation 'before'

  .EXAMPLE 7
  Move last occurrence of whole-word static string before anchor:

  gci ... | Rename-Many -Pattern '\d{2}-data',l -Anchor 'loopz' -Relation 'before' -Whole p

  .EXAMPLE 8
  Move a match before anchor and drop:

  gci ... | Rename-Many -Pattern '\d{2}-data' -Anchor 'loopz' -Relation 'before' -Drop '-'

  * UPDATE EXAMPLES (Paste)

  .EXAMPLE 9
  Update last occurrence of whole-word static string using $Paste:

  gci ... | Rename-Many -Pattern 'data',l -Whole p -Paste '_info_'

  .EXAMPLE 10
  Update a static string using $Paste:

  gci ... | Rename-Many -Pattern 'data' -Paste '_info_'

  .EXAMPLE 11
  Update 2nd occurrence of whole-word match using $Paste and preserve anchor:

  gci ... | Rename-Many -Pattern '\d{2}-data', l -Paste '${_a}_info_'

  .EXAMPLE 12
  Update match contain named capture group using $Paste and preserve the anchor:

  gci ... | Rename-Many -Pattern (?<day>\d{2})-(?<mon>\d{2})-(?<year>\d{2})
    -Paste '(${year})-(${mon})-(${day}) ${_a}'

  .EXAMPLE 13
  Update match contain named capture group using $Paste and preserve the anchor and copy
  whole last occurrence:

  gci ... | Rename-Many -Pattern (?<day>\d{2})-(?<mon>\d{2})-(?<year>\d{2})
    -Copy '[A-Z]{3}',l -Whole c -Paste 'CCY_${_c} (${year})-(${mon})-(${day}) ${_a}'

  * CUT EXAMPLES (Cut)

  .EXAMPLE 14
  Cut a literal token:

  gci ... | Rename-Many -Cut 'data'

  .EXAMPLE 15
  Cut last occurrence of literal token:

  gci ... | Rename-Many -Cut, l 'data'

  .EXAMPLE 16
  Cut the second 2 digit sequence:

  gci ... | Rename-Many -Cut, 2 '\d{2}'

  * APPENDAGE EXAMPLES

  .EXAMPLE 17
  Prefix items with fixed token:

  gci ... | Rename-Many -Prepend 'begin_'

  .EXAMPLE 18
  Append fixed token to items:

  gci ... | Rename-Many -Append '_end'

  #>
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '',
    Justification = 'WhatIf IS accessed and passed into Exchange')]
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingEmptyCatchBlock', '')]
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', '')]
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingWriteHost', '')]
  [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'UpdateInPlace')]
  [Alias('remy')]
  param
  (
    [Parameter(Mandatory, ValueFromPipeline = $true)]
    [System.IO.FileSystemInfo]$underscore,

    [Parameter(ParameterSetName = 'HybridStart', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'HybridEnd', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'MoveToAnchor', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'UpdateInPlace', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'MoveToStart', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'MoveToEnd', Mandatory, Position = 1)]
    [Parameter(ParameterSetName = 'Transformer', Mandatory, Position = 1)]
    [ValidateScript( { { $(test-ValidPatternArrayParam -Arg $_ -AllowWildCard ) } })]
    [Alias('p')]
    [array]$Pattern,

    [Parameter(ParameterSetName = 'MoveToAnchor', Mandatory, Position = 2)]
    [ValidateScript( { $(test-ValidPatternArrayParam -Arg $_) })]
    [Alias('a')]
    [array]$Anchor,

    [Parameter(ParameterSetName = 'HybridStart', Mandatory, Position = 2)]
    [ValidateScript( { $(test-ValidPatternArrayParam -Arg $_) })]
    [Alias('as')]
    [array]$AnchorStart,

    [Parameter(ParameterSetName = 'HybridEnd', Mandatory, Position = 2)]
    [ValidateScript( { $(test-ValidPatternArrayParam -Arg $_) })]
    [Alias('ae')]
    [array]$AnchorEnd,

    [Parameter(ParameterSetName = 'HybridStart')]
    [Parameter(ParameterSetName = 'HybridEnd')]
    [Parameter(ParameterSetName = 'MoveToAnchor')]
    [ValidateSet('before', 'after')]
    [Alias('r')]
    [string]$Relation = 'after',

    [Parameter(ParameterSetName = 'HybridStart')]
    [Parameter(ParameterSetName = 'HybridEnd')]
    [Parameter(ParameterSetName = 'MoveToAnchor')]
    [Parameter(ParameterSetName = 'UpdateInPlace')]
    [Parameter(ParameterSetName = 'Prefix')]
    [Parameter(ParameterSetName = 'Affix')]
    [Parameter(ParameterSetName = 'MoveToStart')]
    [Parameter(ParameterSetName = 'MoveToEnd')]
    [ValidateScript( { { $(test-ValidPatternArrayParam -Arg $_) } })]
    [Alias('co')]
    [array]$Copy,

    [Parameter(ParameterSetName = 'HybridStart')]
    [Parameter(ParameterSetName = 'HybridEnd')]
    [Parameter(ParameterSetName = 'MoveToAnchor', Position = 3)]
    [Parameter(ParameterSetName = 'MoveToStart', Position = 2)]
    [Parameter(ParameterSetName = 'MoveToEnd', Position = 2)]
    [Parameter(ParameterSetName = 'UpdateInPlace', Position = 2)]
    [Alias('w')]
    [string]$With,

    [Parameter(ParameterSetName = 'MoveToStart', Mandatory)]
    [Alias('s')]
    [switch]$Start,

    [Parameter(ParameterSetName = 'MoveToEnd', Mandatory)]
    [Alias('e')]
    [switch]$End,

    [Parameter(ParameterSetName = 'UpdateInPlace', Mandatory)]
    [Alias('ps')]
    [string]$Paste,

    [Parameter(ParameterSetName = 'HybridStart')]
    [Parameter(ParameterSetName = 'HybridEnd')]
    [Parameter(ParameterSetName = 'MoveToAnchor')]
    [Parameter(ParameterSetName = 'MoveToStart')]
    [Parameter(ParameterSetName = 'MoveToEnd')]
    [Alias('dr')]
    [string]$Drop,

    [Parameter(ParameterSetName = 'NoReplacement', Mandatory)]
    [string]$Cut,

    [Parameter(ParameterSetName = 'Prefix', Mandatory)]
    [Alias('pr')]
    [string]$Prepend,

    [Parameter(ParameterSetName = 'Affix', Mandatory)]
    [Alias('ap')]
    [string]$Append,

    # Defining parameter sets for File and Directory, just to ensure both of these switches
    # are mutually exclusive makes the whole parameter set definition exponentially more
    # complex. It's easier just to enforce this with a ValidateScript.
    #
    [Parameter()]
    [Alias('f')]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('Directory')); })]
    [switch]$File,

    [Parameter()]
    [Alias('d')]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('File')); })]
    [switch]$Directory,

    [Parameter()]
    [Alias('x')]
    [string]$Except = [string]::Empty,

    [Parameter()]
    [Alias('i')]
    [string]$Include,

    [Parameter()]
    [ValidateSet('p', 'a', 'c', 'i', 'x', 'u', '*')]
    [Alias('wh')]
    [string]$Whole,

    [Parameter()]
    [scriptblock]$Condition = ( { return $true; }),

    [Parameter()]
    [Alias('t')]
    [ValidateScript( { $_ -gt 0 } )]
    [int]$Top,

    [Parameter(ParameterSetName = 'Transformer', Mandatory)]
    [scriptblock]$Transform,

    [Parameter()]
    [PSCustomObject]$Context = $Loopz.Defaults.Remy.Context,

    [Parameter()]
    [Alias('dg')]
    [switch]$Diagnose,

    [Parameter()]
    [switch]$Test
  )

  begin {
    Write-Debug ">>> Rename-Many [ParameterSet: '$($PSCmdlet.ParameterSetName)]' >>>";

    function get-fixedIndent {
      [OutputType([int])]
      param(
        [Parameter()]
        [hashtable]$Theme,

        [Parameter()]
        [string]$Message = [string]::Empty
      )
      [int]$indent = $Message.Length;

      #          1         2         3         4
      # 1234567890123456789012345678901234567890
      #    [🏷️] Rename Item  // ["No" => "  1",
      #                      |<-- fixed bit -->|
      #
      $indent += $Theme['MESSAGE-SUFFIX'].Length;
      $indent += $Theme['OPEN'].Length;
      $indent += $Theme['FORMAT'].Replace($Theme['KEY-PLACE-HOLDER'], "No").Replace(
        $Theme['VALUE-PLACE-HOLDER'], '999').Length;
      $indent += $Theme['SEPARATOR'].Length;
      return $indent;
    }

    function use-actionParams {
      [OutputType([hashtable])]
      param(
        [Parameter(Mandatory)]
        [hashtable]$exchange,

        [Parameter(Mandatory)]
        $endAdapter
      )
      [string]$action = $_exchange['LOOPZ.REMY.ACTION'];
      [boolean]$diagnose = ($_exchange.ContainsKey('LOOPZ.DIAGNOSE') -and
        $_exchange['LOOPZ.DIAGNOSE']);
      [string]$adjustedName = $endAdapter.GetAdjustedName();

      # To do, make the action applicable in all modes
      # We need extra actions:
      #   + Cut (handled by move-match)
      #   + Add-Appendage append/prepend
      #
      [hashtable]$actionParameters = if ($action -eq 'Add-Appendage') {
        # Bind append/prepend action parameters
        #
        [hashtable]$_params = @{
          'Value'     = $adjustedName;
          'Appendage' = $exchange['LOOPZ.REMY.APPENDAGE'];
          'Type'      = $exchange['LOOPZ.REMY.APPENDAGE.TYPE'];
        }

        $_params;
      }
      else {
        # Bind move/update/(cut/transform) action parameters
        #
        [hashtable]$_params = @{
          'Value' = $adjustedName;
        }

        # Pattern is present for all actions except Cut
        #
        if ($exchange.ContainsKey('LOOPZ.REMY.PATTERN-REGEX')) {
          $_params['Pattern'] = $exchange['LOOPZ.REMY.PATTERN-REGEX'];

          $_params['PatternOccurrence'] = $exchange.ContainsKey('LOOPZ.REMY.PATTERN-OCC') `
            ? $exchange['LOOPZ.REMY.PATTERN-OCC'] : 'f';
        }
        elseif ($exchange.ContainsKey('LOOPZ.REMY.CUT-REGEX')) {
          $_params['Cut'] = $exchange['LOOPZ.REMY.CUT-REGEX'];

          $_params['CutOccurrence'] = $exchange.ContainsKey('LOOPZ.REMY.CUT-OCC') `
            ? $exchange['LOOPZ.REMY.CUT-OCC'] : 'f';
        }

        if ($action -eq 'Move-Match') {
          if ($exchange.ContainsKey('LOOPZ.REMY.ANCHOR.REGEX')) {
            $_params['Anchor'] = $exchange['LOOPZ.REMY.ANCHOR.REGEX'];
          }
          if ($exchange.ContainsKey('LOOPZ.REMY.ANCHOR-OCC')) {
            $_params['AnchorOccurrence'] = $exchange['LOOPZ.REMY.ANCHOR-OCC'];
          }

          if ($exchange.ContainsKey('LOOPZ.REMY.DROP')) {
            $_params['Drop'] = $exchange['LOOPZ.REMY.DROP'];
            $_params['Marker'] = $exchange['LOOPZ.REMY.MARKER'];
          }

          switch ($exchange['LOOPZ.REMY.ANCHOR-TYPE']) {
            'MATCHED-ITEM' {
              if ($exchange.ContainsKey('LOOPZ.REMY.RELATION')) {
                $_params['Relation'] = $exchange['LOOPZ.REMY.RELATION'];
              }
              break;
            }
            'HYBRID-START' {
              if ($exchange.ContainsKey('LOOPZ.REMY.RELATION')) {
                $_params['Relation'] = $exchange['LOOPZ.REMY.RELATION'];
              }
              $_params['Start'] = $true;
              break;
            }
            'HYBRID-END' {
              if ($exchange.ContainsKey('LOOPZ.REMY.RELATION')) {
                $_params['Relation'] = $exchange['LOOPZ.REMY.RELATION'];
              }
              $_params['End'] = $true;
              break;
            }
            'START' {
              $_params['Start'] = $true;
              break;
            }
            'END' {
              $_params['End'] = $true;
              break;
            }
            'CUT' {
              # no op
              break;
            }
            default {
              throw "doRenameFsItems: encountered Invalid 'LOOPZ.REMY.ANCHOR-TYPE': '$AnchorType'";
            }
          }
        } # $action

        $_params;
      }

      # Bind generic action parameters
      #
      if ($diagnose) {
        $actionParameters['Diagnose'] = $exchange['LOOPZ.DIAGNOSE'];
      }

      if ($exchange.ContainsKey('LOOPZ.REMY.COPY.REGEX')) {
        $actionParameters['Copy'] = $exchange['LOOPZ.REMY.COPY.REGEX'];

        if ($exchange.ContainsKey('LOOPZ.REMY.COPY-OCC')) {
          $actionParameters['CopyOccurrence'] = $exchange['LOOPZ.REMY.COPY-OCC'];
        }
      }

      if ($exchange.ContainsKey('LOOPZ.REMY.WITH')) {
        $actionParameters['With'] = $exchange['LOOPZ.REMY.WITH'];
      }

      if ($exchange.ContainsKey('LOOPZ.REMY.PASTE')) {
        $actionParameters['Paste'] = $exchange['LOOPZ.REMY.PASTE'];
      }

      return $actionParameters;
    } # use-actionParams

    function invoke-HandleError {
      param(
        [Parameter()]
        [string]$message,
        
        [Parameter()]
        [string]$prefix,

        [Parameter()]
        [string]$reThrowIfMatch = $pesterAssertionFailure
      )

      [string]$errorReason = $(
        "$prefix`: " + 
        ($message -split '\n')[0]
      );
      # We need Pester to throw pester specific errors. In the lack of, we have to
      # guess that its a Pester assertion failure and let the exception through so
      # the test fails.
      #
      if ($errorReason -match $reThrowIfMatch) {
        throw $_;
      }

      return $errorReason;
    }

    [scriptblock]$doRenameFsItems = {
      [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', '')]
      param(
        [Parameter(Mandatory)]
        [System.IO.FileSystemInfo]$_underscore,

        [Parameter(Mandatory)]
        [int]$_index,

        [Parameter(Mandatory)]
        [hashtable]$_exchange,

        [Parameter(Mandatory)]
        [boolean]$_trigger
      )

      [boolean]$itemIsDirectory = ($_underscore.Attributes -band
        [System.IO.FileAttributes]::Directory) -eq [System.IO.FileAttributes]::Directory;

      $endAdapter = New-EndAdapter($_underscore);

      [string]$action = $_exchange['LOOPZ.REMY.ACTION'];
      [boolean]$performDiagnosis = ($_exchange.ContainsKey('LOOPZ.DIAGNOSE') -and
        $_exchange['LOOPZ.DIAGNOSE']);

      # ------------------------------------------ [ Bind action parameters ] ---
      #
      [hashtable]$actionParameters = use-actionParams -exchange $_exchange -endAdapter $endAdapter;

      # -------------------------------------------------- [ Execute action ] ---
      #
      [line]$properties = [line]::new();
      [line[]]$lines = @();
      [hashtable]$signals = $_exchange['LOOPZ.SIGNALS'];
      [string]$errorReason = [string]::Empty;

      try {
        [PSCustomObject]$actionResult = & $action @actionParameters;
        [string]$newItemName = $actionResult.Payload;

      }
      catch {
        [string]$newItemName = $_underscore.Name;
        $errorReason = invoke-HandleError -message $_.Exception.Message -prefix 'Action';

        [PSCustomObject]$actionResult = [PSCustomObject]@{
          FailedReason = $errorReason;
          Success = $false;
        }
      }

      try {
        if ([string]::IsNullOrEmpty($errorReason) -and $_exchange.ContainsKey('LOOPZ.REMY.TRANSFORM')) {
          [scriptblock]$transform = $_exchange['LOOPZ.REMY.TRANSFORM'];

          if ($transform) {
            [string]$transformed = $transform.InvokeReturnAsIs(
              [System.IO.Path]::GetFileNameWithoutExtension($_underscore.Name),
              $newItemName,
              $actionResult.CapturedPattern,
              $_exchange
            );

            if (-not([string]::IsNullOrEmpty($transformed))) {
              $newItemName = $transformed;
            }
          }
        }
      }
      catch {
        $errorReason = invoke-HandleError -message $_.Exception.Message -prefix 'Transform';

        [PSCustomObject]$actionResult = [PSCustomObject]@{
          FailedReason = $errorReason;
          Success      = $false;
        }
      }

      $postResult = invoke-PostProcessing -InputSource $newItemName -Rules $Loopz.Rules.Remy `
        -Signals $signals;

      if ($postResult.Modified) {
        [couplet]$postSignal = Get-FormattedSignal -Name 'REMY.POST' `
          -Signals $signals -Value $postResult.Indication -CustomLabel $postResult.Label;
        $properties.append($postSignal);
        $newItemName = $postResult.TransformResult;
      }

      $newItemName = $endAdapter.GetNameWithExtension($newItemName);
      Write-Debug "Rename-Many; New Item Name: '$newItemName'";

      # -------------------------------------------------- [ Perform Rename ] ---
      #
      [string]$parent = $itemIsDirectory ? $_underscore.Parent.FullName : $_underscore.Directory.FullName;
      [boolean]$nameHasChanged = -not($_underscore.Name -ceq $newItemName);
      [string]$newItemFullPath = Join-Path -Path $parent -ChildPath $newItemName;
      [boolean]$clash = (Test-Path -LiteralPath $newItemFullPath) -and $nameHasChanged;
      [boolean]$trigger = $false;
      [boolean]$whatIf = $_exchange.ContainsKey('WHAT-IF') -and ($_exchange['WHAT-IF']);

      if ($nameHasChanged -and -not($clash) -and [string]::IsNullOrEmpty($errorReason)) {
        try {
          $product = rename-FsItem -From $_underscore -To $newItemName -WhatIf:$whatIf -UndoOperant $operant;

          [UndoRename]$operant = $_exchange.ContainsKey('LOOPZ.REMY.UNDO') `
            ? $_exchange['LOOPZ.REMY.UNDO'] : $null;
          $trigger = $true;
        }
        catch {
          $product = $newItemName;
          $errorReason = invoke-HandleError -message $_.Exception.Message -prefix 'Rename';
        }
      }
      else {
        $product = $_underscore;
      }

      # -------------------------------------------- [ Prepare Display Info ] ---
      #
      [string]$fileSystemItemType = $itemIsDirectory ? 'Directory' : 'File';

      [PSCustomObject]$context = $_exchange['LOOPZ.REMY.CONTEXT'];
      [int]$maxItemMessageSize = $_exchange['LOOPZ.REMY.MAX-ITEM-MESSAGE-SIZE'];
      [string]$normalisedItemMessage = $Context.ItemMessage.replace(
        $Loopz.FsItemTypePlaceholder, $fileSystemItemType);

      [string]$messageLabel = if ($context.psobject.properties.match('ItemMessage') -and `
          -not([string]::IsNullOrEmpty($Context.ItemMessage))) {

        Get-PaddedLabel -Label $($Context.ItemMessage.replace(
            $Loopz.FsItemTypePlaceholder, $fileSystemItemType)) -Width $maxItemMessageSize;
      }
      else {
        $normalisedItemMessage;
      }

      [string]$signalName = $itemIsDirectory ? 'DIRECTORY-A' : 'FILE-A';
      [string]$message = Get-FormattedSignal -Name $signalName `
        -Signals $signals -CustomLabel $messageLabel -Format '   [{1}] {0}';

      [int]$magic = 5;
      [int]$indent = $_exchange['LOOPZ.REMY.FIXED-INDENT'] + $message.Length - $magic;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.INDENT'] = $indent;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.MESSAGE'] = $message;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.PRODUCT-LABEL'] = $(Get-PaddedLabel -Label $(
          $fileSystemItemType) -Width 9);

      if (-not([string]::IsNullOrEmpty($errorReason))) {
        $null = $lines += (New-Line(
            New-Pair(@($_exchange['LOOPZ.REMY.FROM-LABEL'], $_underscore.Name))
          ));

        [couplet]$errorSignal = Get-FormattedSignal -Name 'BAD-A' `
          -Signals $signals -CustomLabel 'Error' -Value $errorReason;

        $errorSignal.Affirm = $true;
        $null = $lines += (New-Line(
            $errorSignal
          ));
      }
      elseif ($trigger) {
        $null = $lines += (New-Line(
            New-Pair(@($_exchange['LOOPZ.REMY.FROM-LABEL'], $_underscore.Name))
          ));
      }
      else {
        if ($clash) {
          Write-Debug "!!! doRenameFsItems; path: '$newItemFullPath' already exists, rename skipped";
          [couplet]$clashSignal = Get-FormattedSignal -Name 'CLASH' `
            -Signals $signals -EmojiAsValue -EmojiOnlyFormat '{0}';
          $properties.append($clashSignal);
        }
        else {
          [couplet]$notActionedSignal = Get-FormattedSignal -Name 'NOT-ACTIONED' `
            -Signals $signals -EmojiAsValue -CustomLabel 'Not Renamed' -EmojiOnlyFormat '{0}';
          $properties.append($notActionedSignal);

          [string]$reason = Get-PsObjectField -Object $actionResult -Field 'FailedReason'
          if (-not([string]::IsNullOrEmpty($reason))) {
            [couplet]$becauseSignal = Get-FormattedSignal -Name 'BECAUSE' `
              -Signals $signals -Value $reason;
            $properties.append($becauseSignal);
          }
          elseif (-not($nameHasChanged)) {
            [couplet]$becauseSignal = Get-FormattedSignal -Name 'BECAUSE' `
              -Signals $signals -Value 'Unchanged';
            $properties.append($becauseSignal);
          }
        }
      }

      if ($whatIf) {
        [couplet]$whatIfSignal = Get-FormattedSignal -Name 'WHAT-IF' `
          -Signals $signals -EmojiAsValue -EmojiOnlyFormat '{0}';
        $properties.append($whatIfSignal);
      }

      # -------------------------------------------------- [ Do diagnostics ] ---
      #
      if ($performDiagnosis -and $actionResult.Diagnostics.Named -and
        ($actionResult.Diagnostics.Named.PSBase.Count -gt 0)) {

        [string]$diagnosticEmoji = Get-FormattedSignal -Name 'DIAGNOSTICS' -Signals $signals `
          -EmojiOnly;

        [string]$captureEmoji = Get-FormattedSignal -Name 'CAPTURE' -Signals $signals `
          -EmojiOnly -EmojiOnlyFormat '[{0}]';

        foreach ($namedItem in $actionResult.Diagnostics.Named) {
          foreach ($namedKey in $namedItem.Keys) {
            [hashtable]$groups = $actionResult.Diagnostics.Named[$namedKey];
            [string[]]$diagnosticLines = @();

            foreach ($groupName in $groups.Keys) {
              [string]$captured = $groups[$groupName];
              [string]$compoundValue = "({0} <{1}>)='{2}'" -f $captureEmoji, $groupName, $captured;
              [string]$namedLabel = Get-PaddedLabel -Label ($diagnosticEmoji + $namedKey);

              $diagnosticLines += $compoundValue;
            }
            $null = $lines += (New-Line(
                New-Pair(@($namedLabel, $($diagnosticLines -join ', ')))
              ));
          }
        }
      }

      # -------------------------------------------------- [ Compose Result ] ---
      #
      [PSCustomObject]$result = [PSCustomObject]@{
        Product = $product;
      }

      $result | Add-Member -MemberType NoteProperty -Name 'Pairs' -Value $properties;

      if ($lines.Length -gt 0) {
        $result | Add-Member -MemberType NoteProperty -Name 'Lines' -Value $lines;
      }

      if ($trigger) {
        $result | Add-Member -MemberType NoteProperty -Name 'Trigger' -Value $true;
      }

      [boolean]$differsByCaseOnly = $newItemName.ToLower() -eq $_underscore.Name.ToLower();
      [boolean]$affirm = $trigger -and ($product) -and -not($differsByCaseOnly);
      if ($affirm) {
        $result | Add-Member -MemberType NoteProperty -Name 'Affirm' -Value $true;
      }

      if (-not([string]::IsNullOrEmpty($errorReason))) {
        $result | Add-Member -MemberType NoteProperty -Name 'ErrorReason' -Value $errorReason;
      }

      return $result;
    } # doRenameFsItems

    [scriptblock]$getResult = {
      param($result)

      $result.GetType() -in @([System.IO.FileInfo], [System.IO.DirectoryInfo]) ? $result.Name : $result;
    }

    [string]$pesterAssertionFailure = 'Expected strings to be the same, but they were different';

    [System.IO.FileSystemInfo[]]$collection = @();

    [Krayon]$_krayon = Get-Krayon
    [Scribbler]$_scribbler = New-Scribbler -Krayon $_krayon -Test:$Test.IsPresent;
  } # begin

  process {
    Write-Debug "=== Rename-Many [$($underscore.Name)] ===";

    $collection += $underscore;
  }

  end {
    Write-Debug '<<< Rename-Many <<<';

    # ------------------------------------------------------ [ Init Phase ] ---
    #
    [hashtable]$signals = $(Get-Signals);
    [hashtable]$theme = $_scribbler.Krayon.Theme;
    [boolean]$locked = Get-IsLocked -Variable $(
      [string]::IsNullOrEmpty($Context.Locked) ? 'LOOPZ_REMY_LOCKED' : $Context.Locked
    );

    [string]$title = $Context.psobject.properties.match('Title') -and `
      -not([string]::IsNullOrEmpty($Context.Title)) `
      ? $Context.Title : 'Rename';

    if ($locked) {
      $title = Get-FormattedSignal -Name 'LOCKED' -Signals $signals `
        -Format '{1} {0} {1}' -CustomLabel $('Locked: ' + $title);
    }

    [boolean]$whatIf = $PSBoundParameters.ContainsKey('WhatIf') -or $locked;
    [PSCustomObject]$containers = [PSCustomObject]@{
      Wide  = [line]::new();
      Props = [line]::new();
    }

    [int]$maxItemMessageSize = $Context.ItemMessage.replace(
      $Loopz.FsItemTypePlaceholder, 'Directory').Length;

    [string]$summaryMessage = $Context.psobject.properties.match('SummaryMessage') -and `
      -not([string]::IsNullOrEmpty($Context.SummaryMessage)) `
      ? $Context.SummaryMessage : 'Rename Summary';

    $summaryMessage = Get-FormattedSignal -Name 'SUMMARY-A' -Signals $signals -CustomLabel $summaryMessage;

    [hashtable]$rendezvous = @{
      'LOOPZ.SCRIBBLER'                       = $_scribbler;
      'LOOPZ.SIGNALS'                         = $signals;

      'LOOPZ.WH-FOREACH-DECORATOR.BLOCK'      = $doRenameFsItems;
      'LOOPZ.WH-FOREACH-DECORATOR.GET-RESULT' = $getResult;

      'LOOPZ.HEADER-BLOCK.CRUMB-SIGNAL'       = 'CRUMB-A';
      'LOOPZ.HEADER-BLOCK.LINE'               = $LoopzUI.DashLine;
      'LOOPZ.HEADER-BLOCK.MESSAGE'            = $title;

      'LOOPZ.SUMMARY-BLOCK.LINE'              = $LoopzUI.EqualsLine;
      'LOOPZ.SUMMARY-BLOCK.MESSAGE'           = $summaryMessage;

      'LOOPZ.REMY.CONTEXT'                    = $Context;
      'LOOPZ.REMY.MAX-ITEM-MESSAGE-SIZE'      = $maxItemMessageSize;
      'LOOPZ.REMY.FIXED-INDENT'               = get-fixedIndent -Theme $theme;
      'LOOPZ.REMY.FROM-LABEL'                 = Get-PaddedLabel -Label 'From' -Width 9;

      'LOOPZ.REMY.USER-PARAMS'                = $PSBoundParameters;
    }

    [string]$adjustedWhole = if ($PSBoundParameters.ContainsKey('Whole')) {
      $Whole.ToLower();
    }
    else {
      [string]::Empty;
    }

    [PSCustomObject]$bootStrapOptions = [PSCustomObject]@{};
    if (-not([string]::IsNullOrEmpty($adjustedWhole))) {
      $bootStrapOptions | Add-Member -MemberType NoteProperty -Name 'Whole' -Value $adjustedWhole;
    }

    [BootStrap]$bootStrap = New-BootStrap `
      -Exchange $rendezvous `
      -Containers @{ Wide = [line]::new(); Props = [line]::new(); } `
      -Options $bootStrapOptions;

    # ------------------------------------------------ [ Primary Entities ] ---
    # (Note: Keep Signal Registry up to date)
    #

    # [Pattern]
    #
    [PSCustomObject]$patternSpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('Pattern') -and `
        -not([string]::IsNullOrEmpty($Pattern));
      SpecType       = 'regex';
      Name           = 'Pattern';
      Value          = $Pattern;
      Signal         = 'PATTERN';
      WholeSpecifier = 'p';
      RegExKey       = 'LOOPZ.REMY.PATTERN-REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.PATTERN-OCC';
    }
    $bootStrap.Register($patternSpec);

    if ($PSBoundParameters.ContainsKey('Pattern') -and -not([string]::IsNullOrEmpty($Pattern))) {
      [string]$patternExpression, [string]$patternOccurrence = Resolve-PatternOccurrence $Pattern

      Select-SignalContainer -Containers $containers -Name 'PATTERN' `
        -Value $patternExpression -Signals $signals;
    }

    # [Anchor]
    #
    [PSCustomObject]$anchorSpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('Anchor') -and `
        -not([string]::IsNullOrEmpty($Anchor));
      SpecType       = 'regex';
      Name           = 'Anchor';
      Value          = $Anchor;
      Signal         = 'REMY.ANCHOR';
      WholeSpecifier = 'a';
      RegExKey       = 'LOOPZ.REMY.ANCHOR.REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.ANCHOR-OCC';
      Keys           = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'MATCHED-ITEM';
      }
    }
    $bootStrap.Register($anchorSpec);

    # [AnchorStart]
    #
    [PSCustomObject]$anchorStartSpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('AnchorStart') -and `
        -not([string]::IsNullOrEmpty($AnchorStart));
      SpecType       = 'regex';
      Name           = 'AnchorStart';
      Value          = $AnchorStart;
      Signal         = 'REMY.ANCHOR';
      WholeSpecifier = 'a';
      RegExKey       = 'LOOPZ.REMY.ANCHOR.REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.ANCHOR-OCC';
      Keys           = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'HYBRID-START';
      }
    }
    $bootStrap.Register($anchorStartSpec);

    # [AnchorEnd]
    #
    [PSCustomObject]$anchorEndSpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('AnchorEnd') -and `
        -not([string]::IsNullOrEmpty($AnchorEnd));
      SpecType       = 'regex';
      Name           = 'AnchorEnd';
      Value          = $AnchorEnd;
      Signal         = 'REMY.ANCHOR';
      WholeSpecifier = 'a';
      RegExKey       = 'LOOPZ.REMY.ANCHOR.REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.ANCHOR-OCC';
      Keys           = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'HYBRID-END';
      }
    }
    $bootStrap.Register($anchorEndSpec);

    # [Copy]
    #
    [PSCustomObject]$copySpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('Copy') -and `
        -not([string]::IsNullOrEmpty($Copy));
      SpecType       = 'regex';
      Name           = 'Copy';
      Value          = $Copy;
      Signal         = 'COPY-A';
      WholeSpecifier = 'c';
      RegExKey       = 'LOOPZ.REMY.COPY.REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.COPY-OCC';
    }
    $bootStrap.Register($copySpec);

    # [With]
    #
    [PSCustomObject]$withSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('With') -and `
        -not([string]::IsNullOrEmpty($With));
      SpecType    = 'formatter';
      Name        = 'With';
      Value       = $With;
      Signal      = 'WITH';
      SignalValue = $With;
      Keys        = @{
        'LOOPZ.REMY.WITH' = $With;
      }
    }
    $bootStrap.Register($withSpec);

    # [Include]
    #
    [PSCustomObject]$includeSpec = [PSCustomObject]@{
      Activate      = $PSBoundParameters.ContainsKey('Include') -and `
        -not([string]::IsNullOrEmpty($Include));
      SpecType      = 'regex';
      Name          = 'Include';
      Value         = $Include;
      Signal        = 'INCLUDE';
      RegExKey      = 'LOOPZ.REMY.INCLUDE.REGEX';
      OccurrenceKey = 'LOOPZ.REMY.INCLUDE-OCC';
    }
    $bootStrap.Register($includeSpec);

    # [Except]
    #
    [PSCustomObject]$exceptSpec = [PSCustomObject]@{
      Activate      = $PSBoundParameters.ContainsKey('Except') -and `
        -not([string]::IsNullOrEmpty($Except));
      SpecType      = 'regex';
      Name          = 'Except';
      Value         = $Except;
      Signal        = 'EXCLUDE';
      RegExKey      = 'LOOPZ.REMY.EXCLUDE.REGEX';
      OccurrenceKey = 'LOOPZ.REMY.EXCLUDE-OCC';
    }
    $bootStrap.Register($exceptSpec);

    # [Diagnose]
    #
    [PSCustomObject]$diagnoseSpec = [PSCustomObject]@{
      Activate    = $Diagnose.ToBool();
      SpecType    = 'signal';
      Name        = 'Diagnose';
      Value       = $true;
      Signal      = 'DIAGNOSTICS';
      SignalValue = $('[{0}]' -f $signals['SWITCH-ON'].Value);
      Force       = 'Props';
    }
    $bootStrap.Register($diagnoseSpec);

    # [Paste]
    #
    [PSCustomObject]$pasteSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Paste') -and `
        -not([string]::IsNullOrEmpty($Paste));
      Name        = 'Paste';
      Value       = $Paste;
      SpecType    = 'formatter';
      Signal      = 'PASTE-A';
      SignalValue = $Paste;
      Keys        = @{
        'LOOPZ.REMY.PASTE' = $Paste;
      }
    }
    $bootStrap.Register($pasteSpec);

    # [Append]
    #
    [PSCustomObject]$appendSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Append') -and `
        -not([string]::IsNullOrEmpty($Append));
      Name        = 'Append';
      Value       = $Append;
      SpecType    = 'formatter';
      Signal      = 'APPEND';
      SignalValue = $Append;
      Keys        = @{
        'LOOPZ.REMY.APPENDAGE'      = $Append;
        'LOOPZ.REMY.ACTION'         = 'Add-Appendage';
        'LOOPZ.REMY.APPENDAGE.TYPE' = 'Append';
      }
    }
    $bootStrap.Register($appendSpec);

    # [Prepend]
    #
    [PSCustomObject]$prependSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Prepend') -and `
        -not([string]::IsNullOrEmpty($Prepend));
      Name        = 'Prepend';
      Value       = $Prepend;
      SpecType    = 'formatter';
      Signal      = 'PREPEND';
      SignalValue = $Prepend;
      Keys        = @{
        'LOOPZ.REMY.APPENDAGE'      = $Prepend;
        'LOOPZ.REMY.ACTION'         = 'Add-Appendage';
        'LOOPZ.REMY.APPENDAGE.TYPE' = 'Prepend';
      }
    }
    $bootStrap.Register($prependSpec);

    # [Start]
    #
    [PSCustomObject]$startSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Start') -and $Start;
      Name        = 'Start';
      SpecType    = 'signal';
      Value       = $true;
      Signal      = 'REMY.ANCHOR';
      CustomLabel = 'Start';
      Force       = 'Props';
      SignalValue = $signals['SWITCH-ON'].Value;
      Keys        = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'START';
      };
    }
    $bootStrap.Register($startSpec);

    # [End]
    #
    [PSCustomObject]$endSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('End') -and $End;
      Name        = 'End';
      SpecType    = 'signal';
      Value       = $true;
      Signal      = 'REMY.ANCHOR';
      CustomLabel = 'End';
      Force       = 'Props';
      SignalValue = $signals['SWITCH-ON'].Value;
      Keys        = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'END';
      };
    }
    $bootStrap.Register($endSpec);

    # [Drop]
    #
    [PSCustomObject]$dropSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Drop') -and `
        -not([string]::IsNullOrEmpty($Drop));
      Name        = 'Drop';
      Value       = $Drop;
      SpecType    = 'formatter';
      Signal      = 'REMY.DROP';
      SignalValue = $Drop;
      Force       = 'Wide';
      Keys        = @{
        'LOOPZ.REMY.DROP'   = $Drop;
        'LOOPZ.REMY.MARKER' = $Loopz.Defaults.Remy.Marker;
      }
    }
    $bootStrap.Register($dropSpec);

    # [Novice]
    #
    [PSCustomObject]$noviceSpec = [PSCustomObject]@{
      Activate    = $locked;
      Name        = 'Novice';
      SpecType    = 'signal';
      Signal      = 'NOVICE';
      SignalValue = $signals['SWITCH-ON'].Value;
      Force       = 'Wide';
    }
    $bootStrap.Register($noviceSpec);

    # [Transform]
    #
    [PSCustomObject]$transformSpec = [PSCustomObject]@{
      Activate    = $PSBoundParameters.ContainsKey('Transform') -and $Transform;
      SpecType    = 'signal';
      Name        = 'Transform';
      Signal      = 'TRANSFORM';
      SignalValue = $signals['SWITCH-ON'].Value;
      Force       = 'Wide';
      Keys        = @{
        'LOOPZ.REMY.TRANSFORM' = $Transform;
      }
    }
    $bootStrap.Register($transformSpec);

    # [Undo]
    #
    [PSCustomObject]$operantOptions = [PSCustomObject]@{
      ShortCode     = $Context.OperantShortCode;
      OperantName   = 'UndoRename';
      Shell         = 'PoShShell';
      BaseFilename  = 'undo-rename';
      DisabledEnVar = $Context.UndoDisabledEnVar;
    }
    [UndoRename]$operant = Initialize-ShellOperant -Options $operantOptions -DryRun:$whatIf;

    [PSCustomObject]$undoSpec = [PSCustomObject]@{
      Activate    = $true;
      SpecType    = 'signal';
      Name        = 'Undo';
      Signal      = 'REMY.UNDO';
      SignalValue = $($operant ? $operant.Shell.FullPath : $signals['SWITCH-OFF'].Value);
      Force       = 'Wide';
      Keys        = @{
        'LOOPZ.REMY.UNDO' = $operant;
      }
    }
    $bootStrap.Register($undoSpec);

    # [Relation]
    #
    [PSCustomObject]$relationSpec = [PSCustomObject]@{
      Activate = $PSBoundParameters.ContainsKey('Relation') -and `
        -not([string]::IsNullOrEmpty($Relation));
      Name     = 'Relation';
      SpecType = 'simple';
      Value    = $Relation;
      Keys     = @{
        'LOOPZ.REMY.RELATION' = $Relation;
      }
    }
    $bootStrap.Register($relationSpec);

    # [Cut]
    #
    [PSCustomObject]$cutSpec = [PSCustomObject]@{
      Activate       = $PSBoundParameters.ContainsKey('Cut') -and $Cut;
      SpecType       = 'regex';
      Name           = 'Cut';
      Value          = $Cut;
      Signal         = 'CUT-A';
      WholeSpecifier = 'u';
      RegExKey       = 'LOOPZ.REMY.CUT-REGEX';
      OccurrenceKey  = 'LOOPZ.REMY.CUT-OCC';
      Keys           = @{
        'LOOPZ.REMY.ACTION'      = 'Move-Match';
        'LOOPZ.REMY.ANCHOR-TYPE' = 'CUT';
      }
    }
    $bootStrap.Register($cutSpec);

    # ------------------------------------------------------- [ Relations ] ---
    #

    # [IsMove] (Doesn't need to define the action, its simply a flag. To determine
    # if the operation is a move, can use the presence of this entity as an indicator)
    #
    [PSCustomObject]$isMoveSpec = [PSCustomObject]@{
      Activator = [scriptblock] {
        [OutputType([boolean])]
        param(
          [hashtable]$Entities,
          [hashtable]$Relations
        )

        [boolean]$result = $Entities.ContainsKey('Anchor') -or `
          $Entities.ContainsKey('Start') -or $Entities.ContainsKey('End') -or `
          $Entities.ContainsKey('AnchorStart') -or $Entities.ContainsKey('AnchorEnd');

        return $result;
      }
      Name      = 'IsMove';
      SpecType  = 'simple';
    }

    # [IsUpdate]
    #
    [PSCustomObject]$isUpdateSpec = [PSCustomObject]@{
      Activator = [scriptblock] {
        [OutputType([boolean])]
        param(
          [hashtable]$Entities,
          [hashtable]$Relations
        )
        [boolean]$result = $(-not($Relations.Contains('IsMove')) -and `
            -not($Entities.Contains('Append')) -and `
            -not($Entities.Contains('Prepend')) -and `
            -not($Entities.Contains('Cut'))
        );
        return $result;
      }
      Name      = 'IsUpdate';
      SpecType  = 'simple';
      Keys      = @{
        'LOOPZ.REMY.ACTION' = 'Update-Match';
      }
    }

    # Bootstrap ***
    #
    $null = $bootStrap.Build(@($isMoveSpec, $isUpdateSpec));

    # --------------------------------------- [ Bootstrap dependent setup ] ---
    #

    [RegexEntity]$patternEntity = $bootStrap.Get('Pattern');
    if ($bootStrap.Contains('IsMove')) {
      # !!! This is now redundant; replace-all functionality can no longer be invoked.
      # This will be implemented as a separate derivative command that uses Transform.
      # 
      if ($patternEntity -and $patternEntity.Occurrence -eq '*') {
        [string]$errorMessage = "'Pattern' wildcard prohibited for move operation (Anchor/Start/End).`r`n";
        $errorMessage += "Please use a digit, 'f' (first) or 'l' (last) for Pattern Occurrence";
        Write-Error $errorMessage -ErrorAction Stop;
      }
    }

    [RegExEntity]$ie = $bootStrap.Get('Include');
    [regex]$includedRegEx = ${ie}?.get_RegEx();

    [RegExEntity]$ee = $bootStrap.Get('Except');
    [regex]$exceptRegEx = ${ee}?.get_RegEx();

    [regex]$patternRegEx = ${patternEntity}?.get_RegEx();

    [scriptblock]$clientCondition = $Condition;
    [scriptblock]$compoundCondition = {
      param(
        [System.IO.FileSystemInfo]$pipelineItem
      )

      [boolean]$clientResult = $clientCondition.InvokeReturnAsIs($pipelineItem);
      [boolean]$isStart = $bootStrap.Contains('Start');
      [boolean]$isEnd = $bootStrap.Contains('End');

      [boolean]$isAlreadyAnchoredAt = if ($isStart -or $isEnd) {
        [hashtable]$anchoredParameters = @{
          'Source'     = $pipelineItem.Name;
          'Expression' = $patternRegEx;
          'Occurrence' = $patternEntity.Occurrence;
        }

        if ($isStart) {
          $anchoredParameters['Start'] = $true;
        }
        else {
          $anchoredParameters['End'] = $true;
        }

        Test-IsAlreadyAnchoredAt @anchoredParameters;
      }
      else {
        $false;
      }

      return $($clientResult -and -not($isAlreadyAnchoredAt));
    } # compoundCondition

    [scriptblock]$invokeCondition = {
      param(
        [System.IO.FileSystemInfo]$pipelineItem
      )
      # Inside the scope of this script block, $Condition is assigned to Invoke-ForeachFsItem's
      # version of the Condition parameter which is this scriptblock and thus results in a stack
      # overflow due to infinite recursion. We need to use a temporary variable so that
      # the client's Condition (Rename-Many) is not accidentally hidden.
      #
      [boolean]$isIncluded = ($null -ne $includedRegEx) ? $includedRegEx.IsMatch($pipelineItem.Name) : $true;
      [boolean]$patternIsMatch = ($null -ne $patternRegEx) ? ($patternRegEx.IsMatch($pipelineItem.Name)) : $true;
      [boolean]$notExcluded = ($null -ne $exceptRegEx) ? -not($exceptRegEx.IsMatch($pipelineItem.Name)) : $true;

      return $patternIsMatch -and $isIncluded -and `
        $notExcluded -and $compoundCondition.InvokeReturnAsIs($pipelineItem);
    }

    # ------------------------------------------------- [ Execution Phase ] ---
    #

    [hashtable]$feParameters = @{
      'Condition' = $invokeCondition;
      'Exchange'  = $rendezvous;
      'Header'    = $LoopzHelpers.HeaderBlock;
      'Summary'   = $LoopzHelpers.SummaryBlock;
      'Block'     = $LoopzHelpers.WhItemDecoratorBlock;
    }

    if ($PSBoundParameters.ContainsKey('File')) {
      $feParameters['File'] = $true;
    }
    elseif ($PSBoundParameters.ContainsKey('Directory')) {
      $feParameters['Directory'] = $true;
    }

    if ($PSBoundParameters.ContainsKey('Top')) {
      $feParameters['Top'] = $Top;
    }

    if ($whatIf -or $Diagnose.ToBool()) {
      $rendezvous['WHAT-IF'] = $true;
    }

    if ($Diagnose.ToBool()) {
      $rendezvous['LOOPZ.DIAGNOSE'] = $true;
    }

    [System.Exception]$deferredException = $null;
    try {
      $null = $collection | Invoke-ForeachFsItem @feParameters;
    }
    catch {
      # ctrl-c doesn't invoke an exception, it just abandons processing,
      # ending up in the finally block.
      #
      $deferredException = $_.Exception;
      Write-Host $_.Exception.StackTrace;
    }
    finally {
      # catch ctrl-c
      if ($operant -and -not($whatIf)) {
        $operant.finalise();
      }
    }

    if ($deferredException) {
      throw $deferredException;
    }
  } # end
} # Rename-Many
