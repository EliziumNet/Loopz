
function Rename-Many {
  <#
  .NAME
    Rename-Many

  .SYNOPSIS
    Performs a bulk rename for all file system objects delivered through the pipeline,
  via regular expression replacement.

  .DESCRIPTION
    The user should assemble the candidate items from the file system, be they files or
  directories typically using Get-ChildItem, or can be any other function that delivers
  file systems items via the PowerShell pipeline. For each item in the pipeline,
  Rename-Many will perform a rename.
    Rename-Many is a powerful command and should be used with caution. Because of the
  potential of accidental misuse, a number of protections have been put in place:

  * By default, the command is locked. This means that the command will not actually
  perform any renames until it has been unlocked by the user. When locked, the command
  runs as though -WhatIf has been specified. There are indications in the output to show
  that the command is in a locked state (there is an indicator in the batch header and
  a 'Novice' indicator in the summary). To activate the command, the user needs to
  set the environment variable 'LOOPZ_REMY_LOCKED' to $false. The user should not
  unlock the command until they are comfortable with how to use this command properly
  and knows how to write regular expressions correctly. (See regex101.com)

  * An undo script is generated by default. If the user has invoked a rename operation
  by accident without specifying $WhatIf (or any other WhatIf equivalent like $Diagnose)
  then the user can execute the undo script to reverse the rename operation. The user
  should clearly do this immediately on recognising the error of their ways. In a panic,
  the user may terminate the command via ctrl-c. In this case, a partial undo script is
  still generated and should contain the undo operations for the renames that were
  performed up to the point of the termination request.
    The name of the undo script is based upon the current date and time and is displayed
  in the summary. (The user can, if they wish disable the undo feature if they don't want
  to have to manage the accumulation of undo scripts, by setting the environment variable
  LOOPZ_REMY_UNDO_DISABLED to $true)

  Another important point of note is that there are currently 3 modes of operation:
  'move', 'update' or 'cut':
  * 'move': requires an anchor, which may be an $Anchor pattern or
    either $Start or $End switches.
  * 'update': requires $With or $Paste without an anchor.
  * 'cut': no anchor or $With/$Paste specified, the $Pattern match is simply removed
    from the name.

  The following regular expression parameters:
  * $Pattern
  * $Anchor
  * $Copy
  can optionally have an occurrence value specified that can be used to select which
  match is active. In the case where a provided expression has multiple matches, the
  occurrence value can be used to single out which one. When no occurrence is specified,
  the default is the first match only. The occurrence for a parameter can be:

  * f: first occurrence
  * l: last occurrence
  * <number>: the nth occurrence
  * *: all occurrences. The wild card occurrence can only be used with 'update' or 'cut' operations
  (it doesn't make sense for example to 'move' all occurrences of a pattern to the anchor)
  The occurrence is specified after the regular expression eg:
  -Pattern '\w\d{2,3}', l
    which means match the Last occurrence of the expression.
  (Actually, an occurrence may be specified for $Include and $Exclude but there is no
  point in doing so because these patterns only provide a filtering function and play
  no part in the actual renaming process).

    A note about escaping. If a pattern needs to use an regular expression character as
  a literal, it must be escaped. There are multiple ways of doing this:
  * use the 'esc' function; eg: -Pattern $($esc('(\d{2})'))
  * use a leading ~; -Pattern '~(123)'

  The above 2 approaches escape the entire string. The second approach is more concise
  and avoids the necessary use of extra brackets and $.
  * use 'esc' alongside other string concatenation:
    eg: -Pattern $($esc('(123)') + '-(?<ccy>GBP|SEK)').
  This third method is required when the whole pattern should not be subjected to
  escaping.

  .PARAMETER Anchor
    Indicates that the rename operation will be a move of the token from its original point
  to the point indicated by Anchor. Anchor is a regular expression string applied to the
  pipeline item's name (after the $Pattern match has been removed). The $Pattern match that
  is removed is inserted at the position indicated by the anchor match in collaboration with
  the $Relation parameter.

  .PARAMETER Condition
    Provides another way of filtering pipeline items. This is not typically specified on the
  command line, rather it is meant for those wanting to build functionality on top of Rename-Many.

  .PARAMETER Context
    Provides another way of customising Rename-Many. This is not typically specified on the
  command line, rather it is meant for those wanting to build functionality on top of Rename-Many.
  $Context should be a PSCustomObject with the following note properties:
  * Title (default: 'Rename') the name used in the batch header.
  * ItemMessage (default: 'Rename Item') the operation name used for each renamed item.
  * SummaryMessage (default: 'Rename Summary') the name used in the batch summary.
  * Locked (default: 'LOOPZ_REMY_LOCKED) the name of the environment variable which controls
    the locking of the command.
  * DisabledEnVar (default: 'LOOPZ_REMY_UNDO_DISABLED') the name of the environment variable
    which controls if the undo script feature is disabled.
  * UndoDisabledEnVar (default: 'LOOPZ_REMY_UNDO_DISABLED') the name of the environment
    variable which determines if the Undo feature is disabled. This allows any other function
    built on top of Rename-Many to control the undo feature for itself independently of
    Rename-Many.

  .PARAMETER Copy
    Regular expression string applied to the pipeline item's name (after the $Pattern match
  has been removed), indicating a portion which should be copied and re-inserted (via the
  $Paste parameter; see $Paste or $With). Since this is a regular expression to be used in
  $Paste/$With, there is no value in the user specifying a static pattern, because that
  static string can just be defined in $Paste/$With. The value in the $Copy parameter comes
  when a generic pattern is defined eg \d{3} (is non static), specifies any 3 digits as
  opposed to say '123', which could be used directly in the $Paste/$With parameter without
  the need for $Copy. The match defined by $Copy is stored in special variable ${_c} and
  can be referenced as such from $Paste and $With.

  .PARAMETER Diagnose
    switch parameter that indicates the command should be run in WhatIf mode. When enabled
  it presents additional information that assists the user in correcting the un-expected
  results caused by an incorrect/un-intended regular expression. The current diagnosis
  will show the contents of named capture groups that they may have specified. When an item
  is not renamed (usually because of an incorrect regular expression), the user can use the
  diagnostics along side the 'Not Renamed' reason to track down errors. When $Diagnose has
  been specified, $WhatIf does not need to be specified.

  .PARAMETER Directory
    switch to indicate only Directory items in the pipeline will be processed. If neither
  this switch or the File switch are specified, then both File and Directory items
  are processed.

  .PARAMETER Drop
    A string parameter (only applicable to move operations, ie Anchor/Star/End) that defines
  what text is used to replace the Pattern match. So in this use-case, the user wants to
  move a particular token/pattern to another part of the name and at the same time drop a
  static string in the place where the $Pattern was removed from.

  .PARAMETER End
    Is another type of anchor used instead of $Anchor and specifies that the $Pattern match
  should be moved to the end of the new name.

  .PARAMETER Except
    Regular expression string applied to the original pipeline item's name (before the $Pattern
  match has been removed). Allows the user to exclude some items that have been fed in via the
  pipeline. Those items that match the exclusion are skipped during the rename batch.

  .PARAMETER File
    switch to indicate only File items in the pipeline will be processed. If neither
  this switch or the Directory switch are specified, then both File and Directory items
  are processed.

  .PARAMETER Include
    Regular expression string applied to the original pipeline item's name (before the $Pattern
  match has been removed). Allows the user to include some items that have been fed in via the
  pipeline. Only those items that match $Include pattern are included during the rename batch,
  the others are skipped. The value of the Include parameter comes when you want to define
  a pattern which pipeline items match, without it be removed from the original name, which is
  what happens with $Pattern. Eg, the user may want to specify the only items that should be
  considered a candidate to be renamed are those that match a particular pattern but doing so
  in $Pattern would simply remove that pattern. That may be ok, but if it's not, the user should
  specify a pattern in the $Include and use $Pattern for the match you do want to be moved
  (with Anchor/Start/End) or replaced (with $With/$Paste).

  .PARAMETER Paste
    This is a NON regular expression string. It would be more accurately described as a formatter,
  similar to the $With parameter. When $Paste is defined, the $Anchor (if specified) is removed
  from the original name and needs to be be re-inserted using the special variable ${_a}. The
  other special variables that can be used inside a $Paste string is documented under the $With
  parameter.
    The $Paste string can specify a format that defines the replacement and since it removes the
  $Anchor, the $Relation is not applicable ($Relation and $Paste can't be used together).

  .PARAMETER Pattern
    Regular expression string that indicates which part of the pipeline items' name that
  either needs to be moved or replaced as part of bulk rename operation. Those characters
  in the name which match are removed from the name.
    The pattern can be followed by an occurrence indicator. As the $Pattern parameter is
  strictly speaking an array, the user can specify the occurrence after the regular
  expression eg:
    $Pattern '(?<code>\w\d{2})', l

    => This indicates that the last match should be captured into named group 'code'.

  .PARAMETER Relation
    Used in conjunction with the $Anchor parameter and can be set to either 'before' or
  'after' (the default). Defines the relationship of the $pattern match with the $Anchor
  match in the new name for the pipeline item.

  .PARAMETER Start
    Is another type of anchor used instead of $Anchor and specifies that the $Pattern match
  should be moved to the start of the new name.

  .PARAMETER Top
    A number indicating how many items to process. If it is known that the number of items
  that will be candidates to be renamed is large, the user can limit this is the first $Top
  number of items. This is typically used as an exploratory tool, to determine the effects
  of the rename operation.

  .PARAMETER Transform
    A script block which is given the chance to perform a modification to the finally named
  item. The transform is invoked prior to post-processing, so that the post-processing rules
  are not breached and the transform does not have to worry about breaking them. The transform
  function's signature is as follows:

  * Original: original item's name
  * Renamed: new name
  * CapturedPattern: pattern capture

  and should return the new name. If the transform does not change the name, it should return
  an empty string.

  .PARAMETER Whole
    Provides an alternative way to indicate that the regular expression parameters
  should be treated as a whole word (it just wraps the expression inside \b tokens).
  If set to '*', then it applies to all expression parameters otherwise a single letter
  can specify which of the parameters 'Whole' should be applied to. Valid values are:

  * 'p': $Pattern
  * 'a': $Anchor
  * 'c': $Copy
  * 'i': $Include
  * 'x': $Exclude
  * '*': All the above
  (NB: Currently, can't be set to more than 1 of the above items at a time)

  .PARAMETER With
    This is a NON regular expression string. It would be more accurately described as a formatter,
  similar to the $Paste parameter. Defines what text is used as the replacement for the $Pattern
  match. Works in concert with $Relation (whereas $Paste does not). $With can reference special
  variables:

  * $0: the pattern match
  * ${_a}: the anchor match
  * ${_c}: the copy match

  When $Pattern contains named capture groups, these variables can also be referenced. Eg if the
  $Pattern is defined as '(?<day>\d{1,2})-(?<mon>\d{1,2})-(?<year>\d{4})', then the variables
  ${day}, ${mon} and ${year} also become available for use in $With or $Paste.
  Typically, $With is static text which is used to replace the $Pattern match and is inserted
  according to the Anchor match, (or indeed $Start or $End) and $Relation. When using $With,
  whatever is defined in the $Anchor match is not removed from the pipeline's name (this is
  different to how $Paste works).
    If neither $With or Paste have been specified, then the rename operation becomes a 'Cut'
  operation and will be indicated as such in the batch summary.

  .PARAMETER underscore
    The pipeline item which should either be an instance of FileInfo or DirectoryInfo.

  .EXAMPLE 1
  Move a static string before anchor (consider file items only):
  gci ... | Rename-Many -File -Pattern 'data' -Anchor 'loopz' -Relation 'before'

  .EXAMPLE 2
  Move last occurrence of whole-word static string before anchor:
  gci ... | Rename-Many -Pattern 'data',l -Anchor 'loopz' -Relation 'before' -Whole p

  .EXAMPLE 3
  Move a static string before anchor and drop (consider Directory items only):
  gci ... | Rename-Many -Directory -Pattern 'data' -Anchor 'loopz' -Relation 'before' -Drop '-'

  .EXAMPLE 4
  Update a static string using $With (consider file items only):
  gci ... | Rename-Many -File -Pattern 'data' -With 'info'

  .EXAMPLE 5
  Update last occurrence of whole-word static string using $With:
  gci ... | Rename-Many -Pattern 'data',l -With 'info' -Whole p

  .EXAMPLE 6
  Update a static string using $Paste:
  gci ... | Rename-Many -Pattern 'data' -Paste '_info_'

  .EXAMPLE 7
  Update last occurrence of whole-word static string using $Paste:
  gci ... | Rename-Many -Pattern 'data',l -Whole p -Paste '_info_'

  .EXAMPLE 8
  Move a match before anchor:
  gci ... | Rename-Many -Pattern '\d{2}-data' -Anchor 'loopz' -Relation 'before'

  .EXAMPLE 9
  Move last occurrence of whole-word static string before anchor:
  gci ... | Rename-Many -Pattern '\d{2}-data',l -Anchor 'loopz' -Relation 'before' -Whole p

  .EXAMPLE 10
  Move a match before anchor and drop:
  gci ... | Rename-Many -Pattern '\d{2}-data' -Anchor 'loopz' -Relation 'before' -Drop '-'

  .EXAMPLE 11
  Update a match using $With:
  gci ... | Rename-Many -Pattern '\d{2}-data' -With 'info'

  .EXAMPLE 12
  Update last occurrence of whole-word match using $With:
  gci ... | Rename-Many -Pattern '\d{2}-data',l -With 'info' -Whole p

  .EXAMPLE 13
  Update match contain named capture group using $With:
  gci ... | Rename-Many -Pattern '(?<day>\d{2})-(?<mon>\d{2})-(?<year>\d{2})'
    -With '(${year})-(${mon})-(${day})'

  .EXAMPLE 14
  Update 2nd occurrence of whole-word match using $Paste and preserve anchor:
  gci ... | Rename-Many -Pattern '\d{2}-data', l -Paste '${_a}_info_'

  .EXAMPLE 15
  Update match contain named capture group using $Paste and preserve the anchor:
  gci ... | Rename-Many -Pattern (?<day>\d{2})-(?<mon>\d{2})-(?<year>\d{2})
    -Paste '(${year})-(${mon})-(${day}) ${_a}'

  .EXAMPLE 16
  Update match contain named capture group using $Paste and preserve the anchor and copy
  whole last occurrence:
  gci ... | Rename-Many -Pattern (?<day>\d{2})-(?<mon>\d{2})-(?<year>\d{2})
    -Copy '[A-Z]{3}',l -Whole c -Paste 'CCY_${_c} (${year})-(${mon})-(${day}) ${_a}'

  #>
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSShouldProcess', '',
    Justification = 'WhatIf IS accessed and passed into Exchange')]
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSAvoidUsingEmptyCatchBlock', '')]
  [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', '')]
  [CmdletBinding(SupportsShouldProcess, DefaultParameterSetName = 'ReplaceWith')]
  [Alias('remy')]
  param
  (
    # Defining parameter sets for File and Directory, just to ensure both of these switches
    # are mutually exclusive makes the whole parameter set definition exponentially more
    # complex. It's easier just to enforce this with a ValidateScript.
    #
    [Parameter()]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('Directory')); })]
    [switch]$File,

    [Parameter()]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('File')); })]
    [switch]$Directory,

    [Parameter(Mandatory, ValueFromPipeline = $true)]
    [System.IO.FileSystemInfo]$underscore,

    [Parameter()]
    [ValidateSet('p', 'a', 'c', 'i', 'x', '*')]
    [string]$Whole,

    [Parameter(Mandatory, Position = 0)]
    [ValidateScript( { { $(test-ValidPatternArrayParam -Arg $_ -AllowWildCard ) } })]
    [array]$Pattern,

    [Parameter(ParameterSetName = 'MoveToAnchor', Mandatory)]
    [ValidateScript( { $(test-ValidPatternArrayParam -Arg $_) })]
    [array]$Anchor,

    [Parameter(ParameterSetName = 'MoveToAnchor')]
    [ValidateSet('before', 'after')]
    [string]$Relation = 'after',

    [Parameter(ParameterSetName = 'MoveToAnchor')]
    [Parameter(ParameterSetName = 'ReplaceWith')]
    [ValidateScript( { { $(test-ValidPatternArrayParam -Arg $_) } })]
    [array]$Copy,

    [Parameter(ParameterSetName = 'ReplaceLiteralWith', Mandatory)]
    [string]$With,

    [Parameter()]
    [Alias('x')]
    [string]$Except = [string]::Empty,

    [Parameter()]
    [Alias('i')]
    [string]$Include,

    [Parameter()]
    [scriptblock]$Condition = ( { return $true; }),

    # Both Start & End are members of ReplaceWith, but they shouldn't be supplied at
    # the same time. So how to prevent this? Use ValidateScript instead.
    #
    [Parameter(ParameterSetName = 'ReplaceWith')]
    [Parameter(ParameterSetName = 'MoveToStart', Mandatory)]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('End')); })]
    [switch]$Start,

    [Parameter(ParameterSetName = 'ReplaceWith')]
    [Parameter(ParameterSetName = 'MoveToEnd', Mandatory)]
    [ValidateScript( { -not($PSBoundParameters.ContainsKey('Start')); })]
    [switch]$End,

    [Parameter()]
    [string]$Paste,

    [Parameter()]
    [PSCustomObject]$Context = $Loopz.Defaults.Remy.Context,

    [Parameter()]
    [switch]$Diagnose,

    [Parameter()]
    [string]$Drop,

    [Parameter()]
    [ValidateScript( { $_ -gt 0 } )]
    [int]$Top,

    [Parameter()]
    [scriptblock]$Transform
  )

  begin {
    Write-Debug ">>> Rename-Many [ParameterSet: '$($PSCmdlet.ParameterSetName)]' >>>";

    function get-fixedIndent {
      [OutputType([int])]
      param(
        [Parameter()]
        [hashtable]$Theme,

        [Parameter()]
        [string]$Message = [string]::Empty
      )
      [int]$indent = $Message.Length;

      #          1         2         3         4
      # 1234567890123456789012345678901234567890
      #    [🏷️] Rename Item  // ["No" => "  1",
      #                      |<-- fixed bit -->|
      #
      $indent += $Theme['MESSAGE-SUFFIX'].Length;
      $indent += $Theme['OPEN'].Length;
      $indent += $Theme['FORMAT'].Replace($Theme['KEY-PLACE-HOLDER'], "No").Replace(
        $Theme['VALUE-PLACE-HOLDER'], '999').Length;
      $indent += $Theme['SEPARATOR'].Length;
      return $indent;
    }

    [scriptblock]$doRenameFsItems = {
      [Diagnostics.CodeAnalysis.SuppressMessageAttribute('PSReviewUnusedParameter', '')]
      param(
        [Parameter(Mandatory)]
        [System.IO.FileSystemInfo]$_underscore,

        [Parameter(Mandatory)]
        [int]$_index,

        [Parameter(Mandatory)]
        [hashtable]$_exchange,

        [Parameter(Mandatory)]
        [boolean]$_trigger
      )

      [boolean]$itemIsDirectory = ($_underscore.Attributes -band
        [System.IO.FileAttributes]::Directory) -eq [System.IO.FileAttributes]::Directory;

      $endAdapter = New-EndAdapter($_underscore);
      [string]$adjustedName = $endAdapter.GetAdjustedName();

      [string]$action = $_exchange['LOOPZ.REMY.ACTION'];

      [hashtable]$actionParameters = @{
        'Value'   = $adjustedName;
        'Pattern' = $_exchange['LOOPZ.REMY.PATTERN-REGEX'];
      }

      [boolean]$performDiagnosis = ($_exchange.ContainsKey('LOOPZ.DIAGNOSE') -and
        $_exchange['LOOPZ.DIAGNOSE']);

      $actionParameters['PatternOccurrence'] = $_exchange.ContainsKey('LOOPZ.REMY.PATTERN-OCC') `
        ? $_exchange['LOOPZ.REMY.PATTERN-OCC'] : 'f';

      if ($_exchange.ContainsKey('LOOPZ.REMY.COPY')) {
        $actionParameters['Copy'] = $_exchange['LOOPZ.REMY.COPY'];

        if ($_exchange.ContainsKey('LOOPZ.REMY.COPY-OCC')) {
          $actionParameters['CopyOccurrence'] = $_exchange['LOOPZ.REMY.COPY-OCC'];
        }
      }
      elseif ($_exchange.ContainsKey('LOOPZ.REMY.WITH')) {
        $actionParameters['With'] = $_exchange['LOOPZ.REMY.WITH'];
      }

      if ($_exchange.ContainsKey('LOOPZ.REMY.PASTE')) {
        $actionParameters['Paste'] = $_exchange['LOOPZ.REMY.PASTE']
      }

      if ($performDiagnosis) {
        $actionParameters['Diagnose'] = $_exchange['LOOPZ.DIAGNOSE']
      }

      if ($action -eq 'Move-Match') {
        if ($_exchange.ContainsKey('LOOPZ.REMY.ANCHOR')) {
          $actionParameters['Anchor'] = $_exchange['LOOPZ.REMY.ANCHOR'];
        }
        if ($_exchange.ContainsKey('LOOPZ.REMY.ANCHOR-OCC')) {
          $actionParameters['AnchorOccurrence'] = $_exchange['LOOPZ.REMY.ANCHOR-OCC'];
        }

        if ($_exchange.ContainsKey('LOOPZ.REMY.DROP')) {
          $actionParameters['Drop'] = $_exchange['LOOPZ.REMY.DROP'];
          $actionParameters['Marker'] = $_exchange['LOOPZ.REMY.MARKER'];
        }

        switch ($_exchange['LOOPZ.REMY.ANCHOR-TYPE']) {
          'MATCHED-ITEM' {
            if ($_exchange.ContainsKey('LOOPZ.REMY.RELATION')) {
              $actionParameters['Relation'] = $_exchange['LOOPZ.REMY.RELATION'];
            }
            break;
          }
          'START' {
            $actionParameters['Start'] = $true;
            break;
          }
          'END' {
            $actionParameters['End'] = $true;
            break;
          }
          default {
            throw "doRenameFsItems: encountered Invalid 'LOOPZ.REMY.ANCHOR-TYPE': '$AnchorType'";
          }
        }
      } # $action

      [line]$properties = [line]::new();
      [line[]]$lines = @();
      [hashtable]$signals = $_exchange['LOOPZ.SIGNALS'];

      # Perform Rename Action, then post process
      #
      [PSCustomObject]$actionResult = & $action @actionParameters;
      [string]$newItemName = $actionResult.Payload;

      if ($_exchange.ContainsKey('LOOPZ.REMY.TRANSFORM')) {
        [scriptblock]$transform = $_exchange['LOOPZ.REMY.TRANSFORM'];

        if ($transform) {
          [string]$transformed = $transform.InvokeReturnAsIs(
            $_underscore.Name, $newItemName, $actionResult.CapturedPattern);

          if (-not([string]::IsNullOrEmpty($transformed))) {
            $newItemName = $transformed;
          }
        }
      }

      $postResult = invoke-PostProcessing -InputSource $newItemName -Rules $Loopz.Rules.Remy `
        -Signals $signals;

      if ($postResult.Modified) {
        [couplet]$postSignal = Get-FormattedSignal -Name 'REMY.POST' `
          -Signals $signals -Value $postResult.Indication -CustomLabel $postResult.Label;
        $properties.append($postSignal);
        $newItemName = $postResult.TransformResult;
      }

      $newItemName = $endAdapter.GetNameWithExtension($newItemName);
      Write-Debug "Rename-Many; New Item Name: '$newItemName'";

      [boolean]$trigger = $false;
      [boolean]$affirm = $false;
      [boolean]$whatIf = $_exchange.ContainsKey('WHAT-IF') -and ($_exchange['WHAT-IF']);

      [string]$parent = $itemIsDirectory ? $_underscore.Parent.FullName : $_underscore.Directory.FullName;
      [boolean]$nameHasChanged = -not($_underscore.Name -ceq $newItemName);
      [string]$newItemFullPath = Join-Path -Path $parent -ChildPath $newItemName;
      [boolean]$clash = (Test-Path -LiteralPath $newItemFullPath) -and $nameHasChanged;
      [string]$fileSystemItemType = $itemIsDirectory ? 'Directory' : 'File';

      [PSCustomObject]$context = $_exchange['LOOPZ.REMY.CONTEXT'];
      [int]$maxItemMessageSize = $_exchange['LOOPZ.REMY.MAX-ITEM-MESSAGE-SIZE'];
      [string]$normalisedItemMessage = $Context.ItemMessage.replace(
        $Loopz.FsItemTypePlaceholder, $fileSystemItemType);

      [string]$messageLabel = if ($context.psobject.properties.match('ItemMessage') -and `
          -not([string]::IsNullOrEmpty($Context.ItemMessage))) {

        Get-PaddedLabel -Label $($Context.ItemMessage.replace(
            $Loopz.FsItemTypePlaceholder, $fileSystemItemType)) -Width $maxItemMessageSize;
      }
      else {
        $normalisedItemMessage;
      }

      [string]$signalName = $itemIsDirectory ? 'DIRECTORY-A' : 'FILE-A';
      [string]$message = Get-FormattedSignal -Name $signalName `
        -Signals $signals -CustomLabel $messageLabel -Format '   [{1}] {0}';

      [int]$indent = $_exchange['LOOPZ.REMY.FIXED-INDENT'] + $message.Length;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.INDENT'] = $indent;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.MESSAGE'] = $message;
      $_exchange['LOOPZ.WH-FOREACH-DECORATOR.PRODUCT-LABEL'] = $(Get-PaddedLabel -Label $(
          $fileSystemItemType) -Width 9);

      if ($nameHasChanged -and -not($clash)) {
        $trigger = $true;

        [UndoRename]$operant = $_exchange.ContainsKey('LOOPZ.REMY.UNDO') `
          ? $_exchange['LOOPZ.REMY.UNDO'] : $null;

        $product = rename-FsItem -From $_underscore -To $newItemName -WhatIf:$whatIf -UndoOperant $operant;
      }
      else {
        $product = $_underscore;
      }

      if ($trigger) {
        $null = $lines += (New-Line(
            New-Pair(@($_exchange['LOOPZ.REMY.FROM-LABEL'], $_underscore.Name))
          ));
      }
      else {
        if ($clash) {
          Write-Debug "!!! doRenameFsItems; path: '$newItemFullPath' already exists, rename skipped";
          [couplet]$clashSignal = Get-FormattedSignal -Name 'CLASH' `
            -Signals $signals -EmojiAsValue -EmojiOnlyFormat '{0}';
          $properties.append($clashSignal);
        }
        else {
          [couplet]$notActionedSignal = Get-FormattedSignal -Name 'NOT-ACTIONED' `
            -Signals $signals -EmojiAsValue -CustomLabel 'Not Renamed' -EmojiOnlyFormat '{0}';
          $properties.append($notActionedSignal);
        }
      }

      if (-not($actionResult.Success)) {
        [couplet]$failedSignal = Get-FormattedSignal -Name 'FAILED-A' `
          -Signals $signals -Value $actionResult.FailedReason;
        $properties.append($failedSignal);
      }

      # Do diagnostics
      #
      if ($performDiagnosis -and $actionResult.Diagnostics.Named -and
        ($actionResult.Diagnostics.Named.Count -gt 0)) {

        [string]$diagnosticEmoji = Get-FormattedSignal -Name 'DIAGNOSTICS' -Signals $signals `
          -EmojiOnly;

        [string]$captureEmoji = Get-FormattedSignal -Name 'CAPTURE' -Signals $signals `
          -EmojiOnly -EmojiOnlyFormat '[{0}]';

        foreach ($namedItem in $actionResult.Diagnostics.Named) {
          foreach ($namedKey in $namedItem.Keys) {
            [hashtable]$groups = $actionResult.Diagnostics.Named[$namedKey];
            [string[]]$diagnosticLines = @();

            foreach ($groupName in $groups.Keys) {
              [string]$captured = $groups[$groupName];
              [string]$compoundValue = "({0} <{1}>)='{2}'" -f $captureEmoji, $groupName, $captured;
              [string]$namedLabel = Get-PaddedLabel -Label ($diagnosticEmoji + $namedKey);

              $diagnosticLines += $compoundValue;
            }
            $null = $lines += (New-Line(
                New-Pair(@($namedLabel, $($diagnosticLines -join ', ')))
              ));
          }
        }
      }

      if ($whatIf) {
        [couplet]$whatIfSignal = Get-FormattedSignal -Name 'WHAT-IF' `
          -Signals $signals -EmojiAsValue -EmojiOnlyFormat '{0}';
        $properties.append($whatIfSignal);
      }

      [PSCustomObject]$result = [PSCustomObject]@{
        Product = $product;
      }

      $result | Add-Member -MemberType NoteProperty -Name 'Pairs' -Value $properties;

      if ($lines.Length -gt 0) {
        $result | Add-Member -MemberType NoteProperty -Name 'Lines' -Value $lines;
      }

      if ($trigger) {
        $result | Add-Member -MemberType NoteProperty -Name 'Trigger' -Value $true;
      }

      [boolean]$differsByCaseOnly = $newItemName.ToLower() -eq $_underscore.Name.ToLower();
      [boolean]$affirm = $trigger -and ($product) -and -not($differsByCaseOnly);
      if ($affirm) {
        $result | Add-Member -MemberType NoteProperty -Name 'Affirm' -Value $true;
      }

      return $result;
    } # doRenameFsItems

    [System.IO.FileSystemInfo[]]$collection = @();
  } # begin

  process {
    Write-Debug "=== Rename-Many [$($underscore.Name)] ===";

    $collection += $underscore;
  }

  end {
    Write-Debug '<<< Rename-Many <<<';

    [boolean]$locked = Get-IsLocked -Variable $(
      [string]::IsNullOrEmpty($Context.Locked) ? 'LOOPZ_REMY_LOCKED' : $Context.Locked
    );
    [boolean]$whatIf = $PSBoundParameters.ContainsKey('WhatIf') -or $locked;
    [PSCustomObject]$containers = @{
      Wide  = [line]::new();
      Props = [line]::new();
    }

    [string]$adjustedWhole = if ($PSBoundParameters.ContainsKey('Whole')) {
      $Whole.ToLower();
    }
    else {
      [string]::Empty;
    }

    [hashtable]$signals = $(Get-Signals);

    # RegEx/Occurrence parameters
    #
    [string]$patternExpression, [string]$patternOccurrence = Resolve-PatternOccurrence $Pattern

    Select-SignalContainer -Containers $containers -Name 'PATTERN' `
      -Value $patternExpression -Signals $signals;

    if ($PSBoundParameters.ContainsKey('Anchor')) {
      [string]$anchorExpression, [string]$anchorOccurrence = Resolve-PatternOccurrence $Anchor

      Select-SignalContainer -Containers $containers -Name 'REMY.ANCHOR' `
        -Value $anchorExpression -Signals $signals -CustomLabel $('Anchor ({0})' -f $Relation);
    }

    if ($PSBoundParameters.ContainsKey('Copy')) {
      [string]$copyExpression, [string]$copyOccurrence = Resolve-PatternOccurrence $Copy;

      Select-SignalContainer -Containers $containers -Name 'COPY-A' `
        -Value $copyExpression -Signals $signals;
    }
    elseif ($PSBoundParameters.ContainsKey('With')) {
      if (-not([string]::IsNullOrEmpty($With))) {

        Select-SignalContainer -Containers $containers -Name 'WITH' `
          -Value $With -Signals $signals;
      }
      elseif (-not($PSBoundParameters.ContainsKey('Paste'))) {

        Select-SignalContainer -Containers $containers -Name 'CUT-A' `
          -Value $patternExpression -Signals $signals -Force 'Props';
      }
    }

    if ($PSBoundParameters.ContainsKey('Include')) {
      [string]$includeExpression, [string]$includeOccurrence = Resolve-PatternOccurrence $Include;

      Select-SignalContainer -Containers $containers -Name 'INCLUDE' `
        -Value $includeExpression -Signals $signals;
    }

    if ($PSBoundParameters.ContainsKey('Diagnose')) {
      [string]$switchOnEmoji = $signals['SWITCH-ON'].Value;

      [couplet]$diagnosticsSignal = Get-FormattedSignal -Name 'DIAGNOSTICS' `
        -Signals $signals -Value $('[{0}]' -f $switchOnEmoji);

      $containers.Props.Line += $diagnosticsSignal;
    }

    [boolean]$doMoveToken = ($PSBoundParameters.ContainsKey('Anchor') -or
      $PSBoundParameters.ContainsKey('Start') -or $PSBoundParameters.ContainsKey('End'));

    if ($doMoveToken -and ($patternOccurrence -eq '*')) {
      [string]$errorMessage = "'Pattern' wildcard prohibited for move operation (Anchor/Start/End).`r`n";
      $errorMessage += "Please use a digit, 'f' (first) or 'l' (last) for Pattern Occurrence";
      Write-Error $errorMessage -ErrorAction Stop;
    }

    [boolean]$doCut = (
      -not($doMoveToken) -and
      -not($PSBoundParameters.ContainsKey('Copy')) -and
      -not($PSBoundParameters.ContainsKey('With')) -and
      -not($PSBoundParameters.ContainsKey('Paste'))
    )

    if ($doCut) {
      Select-SignalContainer -Containers $containers -Name 'CUT-A' `
        -Value $patternExpression -Signals $signals -Force 'Props';
    }

    if ($PSBoundParameters.ContainsKey('Paste')) {
      if (-not(Test-IsFileSystemSafe -Value $Paste)) {
        throw [System.ArgumentException]::new("Paste parameter ('$Paste') contains unsafe characters")
      }
      if (-not([string]::IsNullOrEmpty($Paste))) {
        Select-SignalContainer -Containers $containers -Name 'PASTE-A' `
          -Value $Paste -Signals $signals;
      }
    }

    [scriptblock]$getResult = {
      param($result)

      $result.GetType() -in @([System.IO.FileInfo], [System.IO.DirectoryInfo]) ? $result.Name : $result;
    }

    [regex]$patternRegEx = New-RegularExpression -Expression $patternExpression `
      -WholeWord:$(-not([string]::IsNullOrEmpty($adjustedWhole)) -and ($adjustedWhole -in @('*', 'p')));

    [string]$title = $Context.psobject.properties.match('Title') -and `
      -not([string]::IsNullOrEmpty($Context.Title)) `
      ? $Context.Title : 'Rename';

    if ($locked) {
      $title = Get-FormattedSignal -Name 'LOCKED' -Signals $signals `
        -Format '{1} {0} {1}' -CustomLabel $('Locked: ' + $title);
    }

    [int]$maxItemMessageSize = $Context.ItemMessage.replace(
      $Loopz.FsItemTypePlaceholder, 'Directory').Length;

    [string]$summaryMessage = $Context.psobject.properties.match('SummaryMessage') -and `
      -not([string]::IsNullOrEmpty($Context.SummaryMessage)) `
      ? $Context.SummaryMessage : 'Rename Summary';

    $summaryMessage = Get-FormattedSignal -Name 'SUMMARY-A' -Signals $signals -CustomLabel $summaryMessage;

    [hashtable]$theme = $(Get-KrayolaTheme);
    [Krayon]$krayon = New-Krayon -Theme $theme;

    [hashtable]$exchange = @{
      'LOOPZ.WH-FOREACH-DECORATOR.BLOCK'      = $doRenameFsItems;
      'LOOPZ.WH-FOREACH-DECORATOR.GET-RESULT' = $getResult;

      'LOOPZ.HEADER-BLOCK.CRUMB-SIGNAL'       = 'CRUMB-A';
      'LOOPZ.HEADER-BLOCK.LINE'               = $LoopzUI.DashLine;
      'LOOPZ.HEADER-BLOCK.MESSAGE'            = $title;

      'LOOPZ.SUMMARY-BLOCK.LINE'              = $LoopzUI.EqualsLine;
      'LOOPZ.SUMMARY-BLOCK.MESSAGE'           = $summaryMessage;

      'LOOPZ.REMY.PATTERN-REGEX'              = $patternRegEx;
      'LOOPZ.REMY.PATTERN-OCC'                = $patternOccurrence;
      'LOOPZ.REMY.CONTEXT'                    = $Context;
      'LOOPZ.REMY.MAX-ITEM-MESSAGE-SIZE'      = $maxItemMessageSize;
      'LOOPZ.REMY.FIXED-INDENT'               = $(get-fixedIndent -Theme $theme);
      'LOOPZ.REMY.FROM-LABEL'                 = Get-PaddedLabel -Label 'From' -Width 9;

      'LOOPZ.SIGNALS'                         = $signals;
      'LOOPZ.KRAYON'                           = $krayon;
    }
    $exchange['LOOPZ.REMY.ACTION'] = $doMoveToken ? 'Move-Match' : 'Update-Match';

    if ($PSBoundParameters.ContainsKey('Copy')) {
      [regex]$copyRegEx = New-RegularExpression -Expression $copyExpression `
        -WholeWord:$(-not([string]::IsNullOrEmpty($adjustedWhole)) -and ($adjustedWhole -in @('*', 'c')));

      $exchange['LOOPZ.REMY.COPY-OCC'] = $copyOccurrence;
      $exchange['LOOPZ.REMY.COPY'] = $copyRegEx;
    }
    elseif ($PSBoundParameters.ContainsKey('With')) {
      if (-not(Test-IsFileSystemSafe -Value $With)) {
        throw [System.ArgumentException]::new("With parameter ('$With') contains unsafe characters")
      }
      $exchange['LOOPZ.REMY.WITH'] = $With;
    }

    if ($PSBoundParameters.ContainsKey('Relation')) {
      $exchange['LOOPZ.REMY.RELATION'] = $Relation;
    }

    # NB: anchoredRegEx refers to whether -Start or -End anchors have been specified,
    # NOT the -Anchor pattern (when ANCHOR-TYPE = 'MATCHED-ITEM') itself.
    #
    [regex]$anchoredRegEx = $null;

    if ($PSBoundParameters.ContainsKey('Anchor')) {

      [regex]$anchorRegEx = New-RegularExpression -Expression $anchorExpression `
        -WholeWord:$(-not([string]::IsNullOrEmpty($adjustedWhole)) -and ($adjustedWhole -in @('*', 'a')));

      $exchange['LOOPZ.REMY.ANCHOR-OCC'] = $anchorOccurrence;
      $exchange['LOOPZ.REMY.ANCHOR-TYPE'] = 'MATCHED-ITEM';
      $exchange['LOOPZ.REMY.ANCHOR'] = $anchorRegEx;
    }
    elseif ($PSBoundParameters.ContainsKey('Start')) {

      Select-SignalContainer -Containers $containers -Name 'REMY.ANCHOR' `
        -Value $signals['SWITCH-ON'].Value -Signals $signals -CustomLabel 'Start' -Force 'Props';

      $exchange['LOOPZ.REMY.ANCHOR-TYPE'] = 'START';

      [regex]$anchoredRegEx = New-RegularExpression `
        -Expression $('^' + $patternExpression);
    }
    elseif ($PSBoundParameters.ContainsKey('End')) {

      Select-SignalContainer -Containers $containers -Name 'REMY.ANCHOR' `
        -Value $signals['SWITCH-ON'].Value -Signals $signals -CustomLabel 'End' -Force 'Props';

      $exchange['LOOPZ.REMY.ANCHOR-TYPE'] = 'END';

      [regex]$anchoredRegEx = New-RegularExpression `
        -Expression $($patternExpression + '$');
    }

    if ($PSBoundParameters.ContainsKey('Drop') -and -not([string]::IsNullOrEmpty($Drop))) {
      Select-SignalContainer -Containers $containers -Name 'REMY.DROP' `
        -Value $Drop -Signals $signals -Force 'Wide';

      $exchange['LOOPZ.REMY.DROP'] = $Drop;
      $exchange['LOOPZ.REMY.MARKER'] = $Loopz.Defaults.Remy.Marker;
    }

    if ($locked) {
      Select-SignalContainer -Containers $containers -Name 'NOVICE' `
        -Value $signals['SWITCH-ON'].Value -Signals $signals -Force 'Wide';
    }

    [boolean]$includeDefined = $PSBoundParameters.ContainsKey('Include');
    [regex]$includeRegEx = $includeDefined `
      ? (New-RegularExpression -Expression $includeExpression `
        -WholeWord:$(-not([string]::IsNullOrEmpty($adjustedWhole)) -and ($adjustedWhole -in @('*', 'i')))) `
      : $null;

    if ($PSBoundParameters.ContainsKey('Paste')) {
      $exchange['LOOPZ.REMY.PASTE'] = $Paste;
    }

    if ($PSBoundParameters.ContainsKey('Transform')) {
      $exchange['LOOPZ.REMY.TRANSFORM'] = $Transform;

      Select-SignalContainer -Containers $containers -Name 'TRANSFORM' `
        -Value $signals['SWITCH-ON'].Value -Signals $signals -Force 'Wide';
    }

    [PSCustomObject]$operantOptions = [PSCustomObject]@{
      ShortCode    = $Context.OperantShortCode;
      OperantName  = 'UndoRename';
      Shell        = 'PoShShell';
      BaseFilename = 'undo-rename';
      DisabledEnVar  = $Context.UndoDisabledEnVar;
    }
    [UndoRename]$operant = Initialize-ShellOperant -Options $operantOptions -DryRun:$whatIf;

    if ($operant) {
      $exchange['LOOPZ.REMY.UNDO'] = $operant;

      Select-SignalContainer -Containers $containers -Name 'REMY.UNDO' `
        -Value $operant.Shell.FullPath -Signals $signals -Force 'Wide';
    }
    else {
      Select-SignalContainer -Containers $containers -Name 'REMY.UNDO' `
        -Value $signals['SWITCH-OFF'].Value -Signals $signals -Force 'Wide';
    }

    if ($containers.Wide.Line.Length -gt 0) {
      $exchange['LOOPZ.SUMMARY-BLOCK.WIDE-ITEMS'] = $containers.Wide;
    }

    if ($containers.Props.Line.Length -gt 0) {
      $exchange['LOOPZ.SUMMARY.PROPERTIES'] = $containers.Props;
    }

    [scriptblock]$clientCondition = $Condition;
    [scriptblock]$compoundCondition = {
      param(
        [System.IO.FileSystemInfo]$pipelineItem
      )

      [boolean]$clientResult = $clientCondition.InvokeReturnAsIs($pipelineItem);
      [boolean]$isAlreadyAnchoredAt = $anchoredRegEx -and $anchoredRegEx.IsMatch($pipelineItem.Name);

      return $($clientResult -and -not($isAlreadyAnchoredAt));
    };

    [regex]$excludedRegEx = [string]::IsNullOrEmpty($Except) `
      ? $null : $(New-RegularExpression -Expression $Except);

    [scriptblock]$matchesPattern = {
      param(
        [System.IO.FileSystemInfo]$pipelineItem
      )
      # Inside the scope of this script block, $Condition is assigned to Invoke-ForeachFsItem's
      # version of the Condition parameter which is this scriptblock and thus results in a stack
      # overflow due to infinite recursion. We need to use a temporary variable so that
      # the client's Condition (Rename-Many) is not accidentally hidden.
      #
      [boolean]$isIncluded = $includeDefined ? $includeRegEx.IsMatch($pipelineItem.Name) : $true;
      return ($patternRegEx.IsMatch($pipelineItem.Name)) -and $isIncluded -and `
      ((-not($excludedRegEx)) -or -not($excludedRegEx.IsMatch($pipelineItem.Name))) -and `
        $compoundCondition.InvokeReturnAsIs($pipelineItem);
    }

    [hashtable]$parameters = @{
      'Condition' = $matchesPattern;
      'Exchange'  = $exchange;
      'Header'    = $LoopzHelpers.HeaderBlock;
      'Summary'   = $LoopzHelpers.SummaryBlock;
      'Block'     = $LoopzHelpers.WhItemDecoratorBlock;
    }

    if ($PSBoundParameters.ContainsKey('File')) {
      $parameters['File'] = $true;
    }
    elseif ($PSBoundParameters.ContainsKey('Directory')) {
      $parameters['Directory'] = $true;
    }

    if ($PSBoundParameters.ContainsKey('Top')) {
      $parameters['Top'] = $Top;
    }

    if ($whatIf -or $Diagnose.ToBool()) {
      $exchange['WHAT-IF'] = $true;
    }

    if ($Diagnose.ToBool()) {
      $exchange['LOOPZ.DIAGNOSE'] = $true;
    }

    try {
      $null = $collection | Invoke-ForeachFsItem @parameters;
    }
    catch {
      # ctrl-c doesn't invoke an exception, it just abandons processing,
      # ending up in the finally block.
      #
      Write-Host $_.Exception.StackTrace;
      Write-Error $_.Exception.Message;
    }
    finally {
      # catch ctrl-c
      if ($operant -and -not($whatIf)) {
        $operant.finalise();
      }
    }
  } # end
} # Rename-Many
